/* automatically generated by rust-bindgen 0.59.2 */

pub const WITH_OBJECT_DETECTION: u32 = 1;
pub const MAX_CAMERA_PLUGIN: u32 = 4;
pub const MAX_SUBMESH: u32 = 1000;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const MAX_NUMBER_OBJECT: u32 = 75;
pub const MAX_TRAJECTORY_SIZE: u32 = 200;
#[doc = " \\brief Quaternion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Quaternion {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_SL_Quaternion() {
    assert_eq!(
        ::std::mem::size_of::<SL_Quaternion>(),
        16usize,
        concat!("Size of: ", stringify!(SL_Quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Quaternion>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Quaternion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Quaternion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Quaternion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Quaternion>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Quaternion>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Quaternion),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief Vector2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Vector2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SL_Vector2() {
    assert_eq!(
        ::std::mem::size_of::<SL_Vector2>(),
        8usize,
        concat!("Size of: ", stringify!(SL_Vector2))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Vector2>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Vector2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector2>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector2),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief Vector3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_SL_Vector3() {
    assert_eq!(
        ::std::mem::size_of::<SL_Vector3>(),
        12usize,
        concat!("Size of: ", stringify!(SL_Vector3))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Vector3>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Vector3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector3>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector3>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector3),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " \\brief Vector4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Vector4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_SL_Vector4() {
    assert_eq!(
        ::std::mem::size_of::<SL_Vector4>(),
        16usize,
        concat!("Size of: ", stringify!(SL_Vector4))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Vector4>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Vector4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector4>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector4>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Vector4>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Vector4),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief uchar2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Uchar2 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SL_Uchar2() {
    assert_eq!(
        ::std::mem::size_of::<SL_Uchar2>(),
        2usize,
        concat!("Size of: ", stringify!(SL_Uchar2))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Uchar2>(),
        1usize,
        concat!("Alignment of ", stringify!(SL_Uchar2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar2>())).y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar2),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief uchar3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Uchar3 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SL_Uchar3() {
    assert_eq!(
        ::std::mem::size_of::<SL_Uchar3>(),
        3usize,
        concat!("Size of: ", stringify!(SL_Uchar3))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Uchar3>(),
        1usize,
        concat!("Alignment of ", stringify!(SL_Uchar3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar3>())).y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar3>())).z as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar3),
            "::",
            stringify!(z)
        )
    );
}
#[doc = " \\brief uchar4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Uchar4 {
    pub x: ::std::os::raw::c_uchar,
    pub y: ::std::os::raw::c_uchar,
    pub z: ::std::os::raw::c_uchar,
    pub w: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SL_Uchar4() {
    assert_eq!(
        ::std::mem::size_of::<SL_Uchar4>(),
        4usize,
        concat!("Size of: ", stringify!(SL_Uchar4))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Uchar4>(),
        1usize,
        concat!("Alignment of ", stringify!(SL_Uchar4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar4>())).y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar4>())).z as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Uchar4>())).w as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Uchar4),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief Matric4x4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Matrix4f {
    pub p: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_SL_Matrix4f() {
    assert_eq!(
        ::std::mem::size_of::<SL_Matrix4f>(),
        64usize,
        concat!("Size of: ", stringify!(SL_Matrix4f))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Matrix4f>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Matrix4f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Matrix4f>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Matrix4f),
            "::",
            stringify!(p)
        )
    );
}
#[doc = " \\brief Matrix3x3"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Matrix3f {
    pub p: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_SL_Matrix3f() {
    assert_eq!(
        ::std::mem::size_of::<SL_Matrix3f>(),
        36usize,
        concat!("Size of: ", stringify!(SL_Matrix3f))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Matrix3f>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Matrix3f))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Matrix3f>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Matrix3f),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_PoseData {
    pub valid: bool,
    pub timestamp: ::std::os::raw::c_ulonglong,
    pub rotation: SL_Quaternion,
    pub translation: SL_Vector3,
    pub pose_confidence: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_PoseData() {
    assert_eq!(
        ::std::mem::size_of::<SL_PoseData>(),
        48usize,
        concat!("Size of: ", stringify!(SL_PoseData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_PoseData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_PoseData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PoseData>())).valid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PoseData),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PoseData>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PoseData),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PoseData>())).rotation as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PoseData),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PoseData>())).translation as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PoseData),
            "::",
            stringify!(translation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PoseData>())).pose_confidence as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PoseData),
            "::",
            stringify!(pose_confidence)
        )
    );
}
pub const UNITY_PLAN_TYPE_UNITY_PLAN_TYPE_FLOOR: UNITY_PLAN_TYPE = 0;
pub const UNITY_PLAN_TYPE_UNITY_PLAN_TYPE_HIT_HORIZONTAL: UNITY_PLAN_TYPE = 1;
pub const UNITY_PLAN_TYPE_UNITY_PLAN_TYPE_HIT_VERTICAL: UNITY_PLAN_TYPE = 2;
pub const UNITY_PLAN_TYPE_UNITY_PLAN_TYPE_HIT_UNKNOWN: UNITY_PLAN_TYPE = 3;
pub type UNITY_PLAN_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_PlaneData {
    pub error_code: ::std::os::raw::c_int,
    pub type_: UNITY_PLAN_TYPE,
    pub plane_normal: SL_Vector3,
    pub plane_center: SL_Vector3,
    pub plane_transform_position: SL_Vector3,
    pub plane_transform_orientation: SL_Quaternion,
    pub plane_equation: SL_Vector4,
    pub extents: SL_Vector2,
    pub bounds_size: ::std::os::raw::c_int,
    pub bounds: [SL_Vector3; 256usize],
}
#[test]
fn bindgen_test_layout_SL_PlaneData() {
    assert_eq!(
        ::std::mem::size_of::<SL_PlaneData>(),
        3160usize,
        concat!("Size of: ", stringify!(SL_PlaneData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_PlaneData>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_PlaneData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).error_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).plane_normal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(plane_normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).plane_center as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(plane_center)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PlaneData>())).plane_transform_position as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(plane_transform_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PlaneData>())).plane_transform_orientation as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(plane_transform_orientation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).plane_equation as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(plane_equation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).extents as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(extents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).bounds_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(bounds_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_PlaneData>())).bounds as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PlaneData),
            "::",
            stringify!(bounds)
        )
    );
}
#[doc = " \\brief IMU Data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_IMUData {
    pub is_available: bool,
    pub timestamp_ns: ::std::os::raw::c_ulonglong,
    pub angular_velocity: SL_Vector3,
    pub linear_acceleration: SL_Vector3,
    pub angular_velocity_unc: SL_Vector3,
    pub linear_acceleration_unc: SL_Vector3,
    pub orientation: SL_Quaternion,
    pub orientation_covariance: SL_Matrix3f,
    pub angular_velocity_convariance: SL_Matrix3f,
    pub linear_acceleration_convariance: SL_Matrix3f,
}
#[test]
fn bindgen_test_layout_SL_IMUData() {
    assert_eq!(
        ::std::mem::size_of::<SL_IMUData>(),
        192usize,
        concat!("Size of: ", stringify!(SL_IMUData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_IMUData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_IMUData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).is_available as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(is_available)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).timestamp_ns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(timestamp_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).angular_velocity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(angular_velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).linear_acceleration as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(linear_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).angular_velocity_unc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(angular_velocity_unc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_IMUData>())).linear_acceleration_unc as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(linear_acceleration_unc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_IMUData>())).orientation as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_IMUData>())).orientation_covariance as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(orientation_covariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_IMUData>())).angular_velocity_convariance as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(angular_velocity_convariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_IMUData>())).linear_acceleration_convariance as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_IMUData),
            "::",
            stringify!(linear_acceleration_convariance)
        )
    );
}
#[doc = " \\brief Barometer Data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_BarometerData {
    pub is_available: bool,
    pub timestamp_ns: ::std::os::raw::c_ulonglong,
    pub pressure: f32,
    pub relative_altitude: f32,
}
#[test]
fn bindgen_test_layout_SL_BarometerData() {
    assert_eq!(
        ::std::mem::size_of::<SL_BarometerData>(),
        24usize,
        concat!("Size of: ", stringify!(SL_BarometerData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_BarometerData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_BarometerData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_BarometerData>())).is_available as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BarometerData),
            "::",
            stringify!(is_available)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_BarometerData>())).timestamp_ns as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BarometerData),
            "::",
            stringify!(timestamp_ns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_BarometerData>())).pressure as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BarometerData),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_BarometerData>())).relative_altitude as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BarometerData),
            "::",
            stringify!(relative_altitude)
        )
    );
}
#[doc = "< The heading is reliable and not affected by iron interferences."]
pub const SL_HEADING_STATE_SL_HEADING_STATE_GOOD: SL_HEADING_STATE = 0;
#[doc = "< The heading is reliable, but affected by slight iron interferences."]
pub const SL_HEADING_STATE_SL_HEADING_STATE_OK: SL_HEADING_STATE = 1;
#[doc = "< The heading is not reliable because affected by strong iron interferences."]
pub const SL_HEADING_STATE_SL_HEADING_STATE_NOT_GOOD: SL_HEADING_STATE = 2;
#[doc = "< The magnetometer has not been calibrated."]
pub const SL_HEADING_STATE_SL_HEADING_STATE_NOT_CALIBRATED: SL_HEADING_STATE = 3;
#[doc = "< The magnetomer sensor is not available."]
pub const SL_HEADING_STATE_SL_HEADING_STATE_MAG_NOT_AVAILABLE: SL_HEADING_STATE = 4;
pub const SL_HEADING_STATE_SL_HEADING_STATE_LAST: SL_HEADING_STATE = 5;
#[doc = " \\brief Heading state enum"]
pub type SL_HEADING_STATE = ::std::os::raw::c_uint;
#[doc = " \\brief Magnometer Data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_MagnetometerData {
    pub is_available: bool,
    pub timestamp_ns: ::std::os::raw::c_ulonglong,
    pub magnetic_field_c: SL_Vector3,
    pub magnetic_field_unc: SL_Vector3,
    pub magnetic_heading: f32,
    pub magnetic_heading_state: SL_HEADING_STATE,
    pub magnetic_heading_accuracy: f32,
    pub effective_rate: f32,
}
#[test]
fn bindgen_test_layout_SL_MagnetometerData() {
    assert_eq!(
        ::std::mem::size_of::<SL_MagnetometerData>(),
        56usize,
        concat!("Size of: ", stringify!(SL_MagnetometerData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_MagnetometerData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_MagnetometerData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).is_available as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(is_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).timestamp_ns as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(timestamp_ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).magnetic_field_c as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(magnetic_field_c)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).magnetic_field_unc as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(magnetic_field_unc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).magnetic_heading as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(magnetic_heading)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).magnetic_heading_state as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(magnetic_heading_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).magnetic_heading_accuracy as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(magnetic_heading_accuracy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_MagnetometerData>())).effective_rate as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_MagnetometerData),
            "::",
            stringify!(effective_rate)
        )
    );
}
#[doc = " \\brief Temperature Data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_TemperatureData {
    pub imu_temp: f32,
    pub barometer_temp: f32,
    pub onboard_left_temp: f32,
    pub onboard_right_temp: f32,
}
#[test]
fn bindgen_test_layout_SL_TemperatureData() {
    assert_eq!(
        ::std::mem::size_of::<SL_TemperatureData>(),
        16usize,
        concat!("Size of: ", stringify!(SL_TemperatureData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_TemperatureData>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_TemperatureData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_TemperatureData>())).imu_temp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TemperatureData),
            "::",
            stringify!(imu_temp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TemperatureData>())).barometer_temp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TemperatureData),
            "::",
            stringify!(barometer_temp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TemperatureData>())).onboard_left_temp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TemperatureData),
            "::",
            stringify!(onboard_left_temp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TemperatureData>())).onboard_right_temp as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TemperatureData),
            "::",
            stringify!(onboard_right_temp)
        )
    );
}
#[doc = " \\brief Sensor Data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_SensorData {
    pub imu: SL_IMUData,
    pub barometer: SL_BarometerData,
    pub magnetometer: SL_MagnetometerData,
    pub temperature: SL_TemperatureData,
    pub camera_moving_state: ::std::os::raw::c_int,
    pub image_sync_trigger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_SensorData() {
    assert_eq!(
        ::std::mem::size_of::<SL_SensorData>(),
        296usize,
        concat!("Size of: ", stringify!(SL_SensorData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_SensorData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_SensorData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorData>())).imu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(imu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorData>())).barometer as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(barometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorData>())).magnetometer as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(magnetometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorData>())).temperature as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorData>())).camera_moving_state as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(camera_moving_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorData>())).image_sync_trigger as *const _ as usize
        },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorData),
            "::",
            stringify!(image_sync_trigger)
        )
    );
}
pub const USB_DEVICE_USB_DEVICE_OCULUS: USB_DEVICE = 0;
pub const USB_DEVICE_USB_DEVICE_HTC: USB_DEVICE = 1;
pub const USB_DEVICE_USB_DEVICE_STEREOLABS: USB_DEVICE = 2;
pub type USB_DEVICE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USB_product {
    pub id_vendor: ::std::os::raw::c_int,
    pub id_product: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_USB_product() {
    assert_eq!(
        ::std::mem::size_of::<USB_product>(),
        8usize,
        concat!("Size of: ", stringify!(USB_product))
    );
    assert_eq!(
        ::std::mem::align_of::<USB_product>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_product))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<USB_product>())).id_vendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_product),
            "::",
            stringify!(id_vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<USB_product>())).id_product as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_product),
            "::",
            stringify!(id_product)
        )
    );
}
#[doc = "< Standard code for successful behavior."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_SUCCESS: SL_ERROR_CODE = 0;
#[doc = "< Standard code for unsuccessful behavior."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_FAILURE: SL_ERROR_CODE = 1;
#[doc = "< No GPU found or CUDA capability of the device is not supported."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_NO_GPU_COMPATIBLE: SL_ERROR_CODE = 2;
#[doc = "< Not enough GPU memory for this depth mode, try a different mode (such as PERFORMANCE), or increase the minimum depth value (see InitParameters::depth_minimum_distance)."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_NOT_ENOUGH_GPU_MEMORY: SL_ERROR_CODE = 3;
#[doc = "< The ZED camera is not plugged or detected."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CAMERA_NOT_DETECTED: SL_ERROR_CODE = 4;
#[doc = "< The MCU that controls the sensors module has an invalid Serial Number. You can try to recover it launching the 'ZED Diagnostic' tool from the command line with the option '-r'."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_SENSORS_NOT_INITIALIZED: SL_ERROR_CODE = 5;
#[doc = "< a ZED-M or ZED2/2i camera is detected but the sensors (imu,barometer...) cannot be opened. Only for ZED-M or ZED2/2i devices. Unplug/replug is required"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_SENSORS_NOT_AVAILABLE: SL_ERROR_CODE = 6;
#[doc = "< In case of invalid resolution parameter, such as a upsize beyond the original image size in Camera::retrieveImage"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_RESOLUTION: SL_ERROR_CODE = 7;
#[doc = "< This issue can occurs when you use multiple ZED or a USB 2.0 port (bandwidth issue)."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_LOW_USB_BANDWIDTH: SL_ERROR_CODE = 8;
#[doc = "< ZED calibration file is not found on the host machine. Use ZED Explorer or ZED Calibration to get one."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CALIBRATION_FILE_NOT_AVAILABLE: SL_ERROR_CODE = 9;
#[doc = "< ZED calibration file is not valid, try to download the factory one or recalibrate your camera using 'ZED Calibration'."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_CALIBRATION_FILE: SL_ERROR_CODE = 10;
#[doc = "< The provided SVO file is not valid."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_SVO_FILE: SL_ERROR_CODE = 11;
#[doc = "< An recorder related error occurred (not enough free storage, invalid file)."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_SVO_RECORDING_ERROR: SL_ERROR_CODE = 12;
#[doc = "< An SVO related error when NVIDIA based compression cannot be loaded."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_SVO_UNSUPPORTED_COMPRESSION: SL_ERROR_CODE = 13;
#[doc = "<SVO end of file has been reached, and no frame will be available until the SVO position is reset."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_END_OF_SVOFILE_REACHED: SL_ERROR_CODE = 14;
#[doc = "< The requested coordinate system is not available."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_COORDINATE_SYSTEM: SL_ERROR_CODE = 15;
#[doc = "< The firmware of the ZED is out of date. Update to the latest version."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_FIRMWARE: SL_ERROR_CODE = 16;
#[doc = "< An invalid parameter has been set for the function."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_FUNCTION_PARAMETERS: SL_ERROR_CODE = 17;
#[doc = "< In grab() or retrieveXXX() only, a CUDA error has been detected in the process. Activate verbose in SL_Camera::open for more info."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CUDA_ERROR: SL_ERROR_CODE = 18;
#[doc = "< In grab() only, ZED SDK is not initialized. Probably a missing call to SL_Camera::open."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CAMERA_NOT_INITIALIZED: SL_ERROR_CODE = 19;
#[doc = "< Your NVIDIA driver is too old and not compatible with your current CUDA version."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_NVIDIA_DRIVER_OUT_OF_DATE: SL_ERROR_CODE = 20;
#[doc = "< The call of the function is not valid in the current context. Could be a missing call of SL_Camera::open."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_FUNCTION_CALL: SL_ERROR_CODE = 21;
#[doc = "< The SDK wasn't able to load its dependencies or somes assets are missing, the installer should be launched."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CORRUPTED_SDK_INSTALLATION: SL_ERROR_CODE = 22;
#[doc = "< The installed SDK is incompatible SDK used to compile the program."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INCOMPATIBLE_SDK_VERSION: SL_ERROR_CODE = 23;
#[doc = "< The given area file does not exist, check the path."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INVALID_AREA_FILE: SL_ERROR_CODE = 24;
#[doc = "< The area file does not contain enought data to be used or the SL_DEPTH_MODE used during the creation of the area file is different from the one currently set."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_INCOMPATIBLE_AREA_FILE: SL_ERROR_CODE = 25;
#[doc = "< Failed to open the camera at the proper resolution. Try another resolution or make sure that the UVC driver is properly installed."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CAMERA_FAILED_TO_SETUP: SL_ERROR_CODE = 26;
#[doc = "< Your ZED can not be opened, try replugging it to another USB port or flipping the USB-C connector."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CAMERA_DETECTION_ISSUE: SL_ERROR_CODE = 27;
#[doc = "< Cannot start camera stream. Make sure your camera is not already used by another process or blocked by firewall or antivirus."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_CANNOT_START_CAMERA_STREAM: SL_ERROR_CODE = 28;
#[doc = "< No GPU found, CUDA is unable to list it. Can be a driver/reboot issue."]
pub const SL_ERROR_CODE_SL_ERROR_CODE_NO_GPU_DETECTED: SL_ERROR_CODE = 29;
#[doc = "< Plane not found, either no plane is detected in the scene, at the location or corresponding to the floor, or the floor plane doesn't match the prior given"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_PLANE_NOT_FOUND: SL_ERROR_CODE = 30;
#[doc = "< The Object detection module is only compatible with the ZED 2"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CAMERA: SL_ERROR_CODE = 31;
#[doc = "< The module needs the sensors to be enabled (see InitParameters::disable_sensors)"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_MOTION_SENSORS_REQUIRED: SL_ERROR_CODE = 32;
#[doc = "< The module needs a newer version of CUDA"]
pub const SL_ERROR_CODE_SL_ERROR_CODE_MODULE_NOT_COMPATIBLE_WITH_CUDA_VERSION: SL_ERROR_CODE = 33;
#[doc = "\\brief Lists error codes in the ZED SDK."]
pub type SL_ERROR_CODE = ::std::os::raw::c_uint;
#[doc = "< 2208*1242, available framerates: 15 fps."]
pub const SL_RESOLUTION_SL_RESOLUTION_HD2K: SL_RESOLUTION = 0;
#[doc = "< 1920*1080, available framerates: 15, 30 fps."]
pub const SL_RESOLUTION_SL_RESOLUTION_HD1080: SL_RESOLUTION = 1;
#[doc = "< 1280*720, available framerates: 15, 30, 60 fps."]
pub const SL_RESOLUTION_SL_RESOLUTION_HD720: SL_RESOLUTION = 2;
#[doc = "< 672*376, available framerates: 15, 30, 60, 100 fps."]
pub const SL_RESOLUTION_SL_RESOLUTION_VGA: SL_RESOLUTION = 3;
#[doc = "\\brief Represents the available resolution defined in the \\ref cameraResolution list."]
#[doc = "\\note The VGA resolution does not respect the 640*480 standard to better fit the camera sensor (672*376 is used)."]
pub type SL_RESOLUTION = ::std::os::raw::c_uint;
#[doc = "< International System, 1/1000 METER."]
pub const SL_UNIT_SL_UNIT_MILLIMETER: SL_UNIT = 0;
#[doc = "< International System, 1/100 METER."]
pub const SL_UNIT_SL_UNIT_CENTIMETER: SL_UNIT = 1;
#[doc = "< International System, 1 METER"]
pub const SL_UNIT_SL_UNIT_METER: SL_UNIT = 2;
#[doc = "< Imperial Unit, 1/12 FOOT"]
pub const SL_UNIT_SL_UNIT_INCH: SL_UNIT = 3;
#[doc = "< Imperial Unit, 1 FOOT"]
pub const SL_UNIT_SL_UNIT_FOOT: SL_UNIT = 4;
#[doc = "\\brief Lists available unit for measures."]
pub type SL_UNIT = ::std::os::raw::c_uint;
#[doc = "< Standard coordinates system in computer vision. Used in OpenCV : see here : http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html"]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_IMAGE: SL_COORDINATE_SYSTEM = 0;
#[doc = "< Left-Handed with Y up and Z forward. Used in Unity with DirectX."]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_LEFT_HANDED_Y_UP: SL_COORDINATE_SYSTEM = 1;
#[doc = "< Right-Handed with Y pointing up and Z backward. Used in OpenGL."]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_RIGHT_HANDED_Y_UP: SL_COORDINATE_SYSTEM = 2;
#[doc = "< Right-Handed with Z pointing up and Y forward. Used in 3DSMax."]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_RIGHT_HANDED_Z_UP: SL_COORDINATE_SYSTEM = 3;
#[doc = "< Left-Handed with Z axis pointing up and X forward. Used in Unreal Engine."]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_LEFT_HANDED_Z_UP: SL_COORDINATE_SYSTEM = 4;
#[doc = "< Right-Handed with Z pointing up and X forward. Used in ROS (REP 103)."]
pub const SL_COORDINATE_SYSTEM_SL_COORDINATE_SYSTEM_RIGHT_HANDED_Z_UP_X_FWD: SL_COORDINATE_SYSTEM =
    5;
#[doc = "\\brief Lists available coordinates systems for positional tracking and 3D measures."]
#[doc = ""]
#[doc = "\\image html CoordinateSystem.png"]
pub type SL_COORDINATE_SYSTEM = ::std::os::raw::c_uint;
#[doc = "< Defines if the camera can be opened by the SDK"]
pub const SL_CAMERA_STATE_SL_CAMERA_STATE_AVAILABLE: SL_CAMERA_STATE = 0;
#[doc = "<  Defines if the camera is already opened and unavailable"]
pub const SL_CAMERA_STATE_SL_CAMERA_STATE_NOT_AVAILABLE: SL_CAMERA_STATE = 1;
#[doc = "\\brief List of possible camera state"]
pub type SL_CAMERA_STATE = ::std::os::raw::c_uint;
#[doc = "< Defines ZED Camera model"]
pub const SL_MODEL_SL_MODEL_ZED: SL_MODEL = 0;
#[doc = "<  Defines ZED Mini (ZED-M) Camera model"]
pub const SL_MODEL_SL_MODEL_ZED_M: SL_MODEL = 1;
#[doc = "< Defines ZED 2 Camera model"]
pub const SL_MODEL_SL_MODEL_ZED2: SL_MODEL = 2;
#[doc = "< Defines ZED 2i Camera model"]
pub const SL_MODEL_SL_MODEL_ZED2i: SL_MODEL = 3;
#[doc = "\\brief Lists compatible ZED Camera model"]
pub type SL_MODEL = ::std::os::raw::c_uint;
#[doc = "< CPU Memory (Processor side)."]
pub const SL_MEM_SL_MEM_CPU: SL_MEM = 0;
#[doc = "< GPU Memory (Graphic card side)."]
pub const SL_MEM_SL_MEM_GPU: SL_MEM = 1;
#[doc = "\\brief List available memory type"]
pub type SL_MEM = ::std::os::raw::c_uint;
#[doc = "< Three axis Accelerometer sensor to measure the inertial accelerations."]
pub const SL_SENSOR_TYPE_SL_SENSOR_TYPE_ACCELEROMETER: SL_SENSOR_TYPE = 0;
#[doc = "< Three axis Gyroscope sensor to measure the angular velocitiers."]
pub const SL_SENSOR_TYPE_SL_SENSOR_TYPE_GYROSCOPE: SL_SENSOR_TYPE = 1;
#[doc = "< Three axis Magnetometer sensor to measure the orientation of the device respect to the earth magnetic field."]
pub const SL_SENSOR_TYPE_SL_SENSOR_TYPE_MAGNETOMETER: SL_SENSOR_TYPE = 2;
#[doc = "< Barometer sensor to measure the atmospheric pressure."]
pub const SL_SENSOR_TYPE_SL_SENSOR_TYPE_BAROMETER: SL_SENSOR_TYPE = 3;
#[doc = "\\brief List of the available onboard sensors"]
pub type SL_SENSOR_TYPE = ::std::os::raw::c_uint;
#[doc = "< Acceleration [m/s²]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_M_SEC_2: SL_SENSORS_UNIT = 0;
#[doc = "< Angular velocity [deg/s]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_DEG_SEC: SL_SENSORS_UNIT = 1;
#[doc = "< MAgnetic Fiels [uT]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_U_T: SL_SENSORS_UNIT = 2;
#[doc = "< Atmospheric pressure [hPa]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_HPA: SL_SENSORS_UNIT = 3;
#[doc = "< Temperature [°C]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_CELSIUS: SL_SENSORS_UNIT = 4;
#[doc = "< Frequency [Hz]."]
pub const SL_SENSORS_UNIT_SL_SENSORS_UNIT_HERTZ: SL_SENSORS_UNIT = 5;
#[doc = "\\brief List of the available onboard sensors measurement units"]
pub type SL_SENSORS_UNIT = ::std::os::raw::c_uint;
#[doc = "< Left side only."]
pub const SL_SIDE_SL_SIDE_LEFT: SL_SIDE = 0;
#[doc = "< Right side only."]
pub const SL_SIDE_SL_SIDE_RIGHT: SL_SIDE = 1;
#[doc = "< Left and Right side."]
pub const SL_SIDE_SL_SIDE_BOTH: SL_SIDE = 2;
pub type SL_SIDE = ::std::os::raw::c_uint;
pub const SL_INPUT_TYPE_SL_INPUT_TYPE_USB: SL_INPUT_TYPE = 0;
pub const SL_INPUT_TYPE_SL_INPUT_TYPE_SVO: SL_INPUT_TYPE = 1;
pub const SL_INPUT_TYPE_SL_INPUT_TYPE_STREAM: SL_INPUT_TYPE = 2;
pub type SL_INPUT_TYPE = ::std::os::raw::c_uint;
#[doc = "< The transform of SL_Pose will contains the motion with reference to the world frame (previously called PATH)."]
pub const SL_REFERENCE_FRAME_SL_REFERENCE_FRAME_WORLD: SL_REFERENCE_FRAME = 0;
#[doc = "< The transform of SL_Pose will contains the motion with reference to the previous camera frame (previously called POSE)."]
pub const SL_REFERENCE_FRAME_SL_REFERENCE_FRAME_CAMERA: SL_REFERENCE_FRAME = 1;
#[doc = "\\brief Defines which type of position matrix is used to store camera path and pose."]
pub type SL_REFERENCE_FRAME = ::std::os::raw::c_uint;
pub const SL_TIME_REFERENCE_SL_TIME_REFERENCE_IMAGE: SL_TIME_REFERENCE = 0;
#[doc = " Defines the timestamp at the time the frame has been extracted from USB stream."]
pub const SL_TIME_REFERENCE_SL_TIME_REFERENCE_CURRENT: SL_TIME_REFERENCE = 1;
#[doc = "\\brief Lists specific and particular timestamps"]
pub type SL_TIME_REFERENCE = ::std::os::raw::c_uint;
#[doc = "< AVCHD/H264 encoding used in image streaming."]
pub const SL_STREAMING_CODEC_SL_STREAMING_CODEC_H264: SL_STREAMING_CODEC = 0;
#[doc = "<  HEVC/H265 encoding used in image streaming."]
pub const SL_STREAMING_CODEC_SL_STREAMING_CODEC_H265: SL_STREAMING_CODEC = 1;
#[doc = "\\brief List of codec"]
pub type SL_STREAMING_CODEC = ::std::os::raw::c_uint;
#[doc = "< Defines the brightness control. Affected value should be between 0 and 8."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_BRIGHTNESS: SL_VIDEO_SETTINGS = 0;
#[doc = "< Defines the contrast control. Affected value should be between 0 and 8."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_CONTRAST: SL_VIDEO_SETTINGS = 1;
#[doc = "< Defines the hue control. Affected value should be between 0 and 11."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_HUE: SL_VIDEO_SETTINGS = 2;
#[doc = "< Defines the saturation control. Affected value should be between 0 and 8."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_SATURATION: SL_VIDEO_SETTINGS = 3;
#[doc = "< Defines the digital sharpening control. Affected value should be between 0 and 8."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_SHARPNESS: SL_VIDEO_SETTINGS = 4;
#[doc = "< Defines the ISP gamma control. Affected value should be between 1 and 9."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_GAMMA: SL_VIDEO_SETTINGS = 5;
#[doc = "< Defines the gain control. Affected value should be between 0 and 100 for manual control."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_GAIN: SL_VIDEO_SETTINGS = 6;
#[doc = "< Defines the exposure control. Affected value should be between 0 and 100 for manual control.\\n The exposition is mapped linearly in a percentage of the following max values. Special case for the setExposure(0) that corresponds to 0.17072ms.\\n The conversion to milliseconds depends on the framerate: <ul><li>15fps setExposure(100) -> 19.97ms</li><li>30fps setExposure(100) -> 19.97ms</li><li>60fps setExposure(100) -> 10.84072ms</li><li>100fps setExposure(100) -> 10.106624ms</li></ul>"]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_EXPOSURE: SL_VIDEO_SETTINGS = 7;
#[doc = "< Defines if the Gain and Exposure are in automatic mode or not. Setting a Gain or Exposure through @GAIN or @EXPOSURE values will automatically set this value to 0."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_AEC_AGC: SL_VIDEO_SETTINGS = 8;
#[doc = "< Defines the region of interest for automatic exposure/gain computation. To be used with overloaded @setCameraSettings/@getCameraSettings functions."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_AEC_AGC_ROI: SL_VIDEO_SETTINGS = 9;
#[doc = "< Defines the color temperature value. Setting a value will automatically set @WHITEBALANCE_AUTO to 0. Affected value should be between 2800 and 6500 with a step of 100."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_WHITEBALANCE_TEMPERATURE: SL_VIDEO_SETTINGS = 10;
#[doc = "< Defines if the White balance is in automatic mode or not"]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_WHITEBALANCE_AUTO: SL_VIDEO_SETTINGS = 11;
#[doc = "< Defines the status of the camera front LED. Set to 0 to disable the light, 1 to enable the light. Default value is on. Requires Camera FW 1523 at least."]
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_LED_STATUS: SL_VIDEO_SETTINGS = 12;
pub const SL_VIDEO_SETTINGS_SL_VIDEO_SETTINGS_LAST: SL_VIDEO_SETTINGS = 13;
#[doc = "\\brief Lists available camera settings for the ZED camera (contrast, hue, saturation, gain...)."]
#[doc = "\\warning GAIN and EXPOSURE are linked in auto/default mode (see \\ref SL_Camera::setCameraSettings)."]
pub type SL_VIDEO_SETTINGS = ::std::os::raw::c_uint;
pub const SL_MEASURE_SL_MEASURE_DISPARITY: SL_MEASURE = 0;
#[doc = " Disparity map. Each pixel contains 1 float. SL_MAT_TYPE_F32_C1."]
pub const SL_MEASURE_SL_MEASURE_DEPTH: SL_MEASURE = 1;
#[doc = " Depth map. In SL_UNIT defined in SL_InitParameters. Each pixel contains 1 float. SL_MAT_TYPE_F32_C1."]
pub const SL_MEASURE_SL_MEASURE_CONFIDENCE: SL_MEASURE = 2;
#[doc = " Certainty/confidence of the depth map. Each pixel contains 1 float. SL_MAT_TYPE_F32_C1."]
pub const SL_MEASURE_SL_MEASURE_XYZ: SL_MEASURE = 3;
#[doc = " Point cloud. Each pixel contains 4 float (X, Y, Z, not used). SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZRGBA: SL_MEASURE = 4;
#[doc = " Colored point cloud. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the RGBA color.  SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZBGRA: SL_MEASURE = 5;
#[doc = " Colored point cloud. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the BGRA color.  SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZARGB: SL_MEASURE = 6;
#[doc = " Colored point cloud. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the ARGB color.  SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZABGR: SL_MEASURE = 7;
#[doc = " Colored point cloud. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the ABGR color.  SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_NORMALS: SL_MEASURE = 8;
#[doc = "< Disparity map for right sensor. Each pixel contains 1 float. SL_MAT_TYPE_F32_C1."]
pub const SL_MEASURE_SL_MEASURE_DISPARITY_RIGHT: SL_MEASURE = 9;
pub const SL_MEASURE_SL_MEASURE_DEPTH_RIGHT: SL_MEASURE = 10;
#[doc = " Depth map for right sensor. Each pixel contains 1 float. SL_MAT_TYPE_F32_C1."]
pub const SL_MEASURE_SL_MEASURE_XYZ_RIGHT: SL_MEASURE = 11;
#[doc = " Point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, not used). SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZRGBA_RIGHT: SL_MEASURE = 12;
#[doc = " Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the RGBA color. SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZBGRA_RIGHT: SL_MEASURE = 13;
#[doc = " Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the BGRA color. SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZARGB_RIGHT: SL_MEASURE = 14;
#[doc = " Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the ARGB color. SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_XYZABGR_RIGHT: SL_MEASURE = 15;
#[doc = " Colored point cloud for right sensor. Each pixel contains 4 float (X, Y, Z, color). The color need to be read as an usigned char[4] representing the ABGR color. SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_NORMALS_RIGHT: SL_MEASURE = 16;
#[doc = " Normals vector for right view. Each pixel contains 4 float (X, Y, Z, 0).  SL_MAT_TYPE_F32_C4."]
pub const SL_MEASURE_SL_MEASURE_DEPTH_U16_MM: SL_MEASURE = 17;
#[doc = " Depth map in millimeter whatever the SL_UNIT defined in SL_InitParameters. Invalid values are set to 0, depth values are clamped at 65000.  Each pixel  contains 1 unsigned short. SL_MAT_TYPE_U16_C1."]
pub const SL_MEASURE_SL_MEASURE_DEPTH_U16_MM_RIGHT: SL_MEASURE = 18;
#[doc = "\\brief Lists retrievable measures."]
pub type SL_MEASURE = ::std::os::raw::c_uint;
pub const SL_VIEW_SL_VIEW_LEFT: SL_VIEW = 0;
#[doc = " Left BGRA image. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_RIGHT: SL_VIEW = 1;
#[doc = " Right BGRA image. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_LEFT_GRAY: SL_VIEW = 2;
#[doc = " Left GRAY image. Each pixel contains 1 usigned char. SL_MAT_TYPE_U8_C1."]
pub const SL_VIEW_SL_VIEW_RIGHT_GRAY: SL_VIEW = 3;
#[doc = " Right GRAY image. Each pixel contains 1 usigned char. SL_MAT_TYPE_U8_C1."]
pub const SL_VIEW_SL_VIEW_LEFT_UNRECTIFIED: SL_VIEW = 4;
#[doc = " Left BGRA unrectified image. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_RIGHT_UNRECTIFIED: SL_VIEW = 5;
#[doc = " Right BGRA unrectified image. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_LEFT_UNRECTIFIED_GRAY: SL_VIEW = 6;
#[doc = " Left GRAY unrectified image. Each pixel contains 1 usigned char. SL_MAT_TYPE_U8_C1."]
pub const SL_VIEW_SL_VIEW_RIGHT_UNRECTIFIED_GRAY: SL_VIEW = 7;
#[doc = " Right GRAY unrectified image. Each pixel contains 1 usigned char. SL_MAT_TYPE_U8_C1."]
pub const SL_VIEW_SL_VIEW_SIDE_BY_SIDE: SL_VIEW = 8;
#[doc = " Left and right image (the image width is therefore doubled). Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_DEPTH: SL_VIEW = 9;
#[doc = " Color rendering of the depth. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4. Use \\ref MEASURE \"MEASURE_DEPTH\" with \\ref Camera.retrieveMeasure() to get depth values."]
pub const SL_VIEW_SL_VIEW_CONFIDENCE: SL_VIEW = 10;
#[doc = " Color rendering of the depth confidence. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_NORMALS: SL_VIEW = 11;
#[doc = " Color rendering of the normals. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_DEPTH_RIGHT: SL_VIEW = 12;
#[doc = " Color rendering of the right depth mapped on right sensor. Each pixel contains 4 usigned char (B,G,R,A). SL_MAT_TYPE_U8_C4."]
pub const SL_VIEW_SL_VIEW_NORMALS_RIGHT: SL_VIEW = 13;
#[doc = "\\brief Lists available views."]
pub type SL_VIEW = ::std::os::raw::c_uint;
#[doc = "< The tracking is not yet initialized, the object ID is not usable"]
pub const SL_OBJECT_TRACKING_STATE_SL_OBJECT_TRACKING_STATE_OFF: SL_OBJECT_TRACKING_STATE = 0;
#[doc = "< The object is tracked"]
pub const SL_OBJECT_TRACKING_STATE_SL_OBJECT_TRACKING_STATE_OK: SL_OBJECT_TRACKING_STATE = 1;
#[doc = "< The object couldn't be detected in the image and is potentially occluded, the trajectory is estimated"]
pub const SL_OBJECT_TRACKING_STATE_SL_OBJECT_TRACKING_STATE_SEARCHING: SL_OBJECT_TRACKING_STATE = 2;
#[doc = "< This is the last searching state of the track, the track will be deleted in the next retreiveObject"]
pub const SL_OBJECT_TRACKING_STATE_SL_OBJECT_TRACKING_STATE_TERMINATE: SL_OBJECT_TRACKING_STATE = 3;
#[doc = "\\brief Lists available object tracking state"]
pub type SL_OBJECT_TRACKING_STATE = ::std::os::raw::c_uint;
pub const SL_POSITIONAL_TRACKING_STATE_SL_POSITIONAL_TRACKING_STATE_SEARCHING:
    SL_POSITIONAL_TRACKING_STATE = 0;
#[doc = " The camera is searching for a previously known position to locate itself."]
pub const SL_POSITIONAL_TRACKING_STATE_SL_POSITIONAL_TRACKING_STATE_OK:
    SL_POSITIONAL_TRACKING_STATE = 1;
#[doc = " Positional tracking is working normally."]
pub const SL_POSITIONAL_TRACKING_STATE_SL_POSITIONAL_TRACKING_STATE_OFF:
    SL_POSITIONAL_TRACKING_STATE = 2;
#[doc = " Positional tracking is not enabled."]
pub const SL_POSITIONAL_TRACKING_STATE_SL_POSITIONAL_TRACKING_STATE_FPS_TOO_LOW:
    SL_POSITIONAL_TRACKING_STATE = 3;
#[doc = "\\brief Lists the different states of positional tracking."]
pub type SL_POSITIONAL_TRACKING_STATE = ::std::os::raw::c_uint;
#[doc = "< The spatial memory file has been successfully created."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_SUCCESS: SL_AREA_EXPORTING_STATE = 0;
#[doc = "< The spatial memory is currently written."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_RUNNING: SL_AREA_EXPORTING_STATE = 1;
#[doc = "< The spatial memory file exportation has not been called."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_NOT_STARTED: SL_AREA_EXPORTING_STATE = 2;
#[doc = "< The spatial memory contains no data, the file is empty."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_FILE_EMPTY: SL_AREA_EXPORTING_STATE = 3;
#[doc = "< The spatial memory file has not been written because of a wrong file name."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_FILE_ERROR: SL_AREA_EXPORTING_STATE = 4;
#[doc = "< The spatial memory learning is disable, no file can be created."]
pub const SL_AREA_EXPORTING_STATE_SL_AREA_EXPORTING_STATE_SPATIAL_MEMORY_DISABLED:
    SL_AREA_EXPORTING_STATE = 5;
#[doc = "\\brief Lists the different states of spatial memory area export."]
pub type SL_AREA_EXPORTING_STATE = ::std::os::raw::c_uint;
pub const SL_SPATIAL_MAPPING_STATE_SL_SPATIAL_MAPPING_STATE_INITIALIZING: SL_SPATIAL_MAPPING_STATE =
    0;
#[doc = " The spatial mapping is initializing."]
pub const SL_SPATIAL_MAPPING_STATE_SL_SPATIAL_MAPPING_STATE_OK: SL_SPATIAL_MAPPING_STATE = 1;
#[doc = " The depth and tracking data were correctly integrated in the fusion algorithm."]
pub const SL_SPATIAL_MAPPING_STATE_SL_SPATIAL_MAPPING_STATE_NOT_ENOUGH_MEMORY:
    SL_SPATIAL_MAPPING_STATE = 2;
#[doc = " The maximum memory dedicated to the scanning has been reach, the mesh will no longer be updated."]
pub const SL_SPATIAL_MAPPING_STATE_SL_SPATIAL_MAPPING_STATE_NOT_ENABLED: SL_SPATIAL_MAPPING_STATE =
    3;
#[doc = " Camera::enableSpatialMapping() wasn't called (or the scanning was stopped and not relaunched)."]
pub const SL_SPATIAL_MAPPING_STATE_SL_SPATIAL_MAPPING_STATE_FPS_TOO_LOW: SL_SPATIAL_MAPPING_STATE =
    4;
#[doc = "\\brief Gives the spatial mapping state."]
pub type SL_SPATIAL_MAPPING_STATE = ::std::os::raw::c_uint;
#[doc = "< Represents a surface with faces, 3D points are linked by edges, no color information."]
pub const SL_SPATIAL_MAP_TYPE_SL_SPATIAL_MAP_TYPE_MESH: SL_SPATIAL_MAP_TYPE = 0;
#[doc = "< Geometry is represented by a set of 3D colored points."]
pub const SL_SPATIAL_MAP_TYPE_SL_SPATIAL_MAP_TYPE_FUSED_POINT_CLOUD: SL_SPATIAL_MAP_TYPE = 1;
#[doc = "\\brief Lists the types of spatial maps that can be created."]
pub type SL_SPATIAL_MAP_TYPE = ::std::os::raw::c_uint;
#[doc = "< Clean the mesh by closing small holes and removing isolated faces."]
pub const SL_MESH_FILTER_SL_MESH_FILTER_LOW: SL_MESH_FILTER = 0;
#[doc = "< Soft decimation and smoothing."]
pub const SL_MESH_FILTER_SL_MESH_FILTER_MEDIUM: SL_MESH_FILTER = 1;
#[doc = "< Decimate the number of triangles and apply a soft smooth."]
pub const SL_MESH_FILTER_SL_MESH_FILTER_HIGH: SL_MESH_FILTER = 2;
#[doc = "\\brief Lists available mesh filtering intensity."]
pub type SL_MESH_FILTER = ::std::os::raw::c_uint;
#[doc = "< Contains only vertices and faces."]
pub const SL_MESH_FILE_FORMAT_SL_MESH_FILE_FORMAT_PLY: SL_MESH_FILE_FORMAT = 0;
#[doc = "< Contains only vertices and faces, encoded in binary."]
pub const SL_MESH_FILE_FORMAT_SL_MESH_FILE_FORMAT_PLY_BIN: SL_MESH_FILE_FORMAT = 1;
#[doc = "< Contains vertices, normals, faces and textures informations if possible."]
pub const SL_MESH_FILE_FORMAT_SL_MESH_FILE_FORMAT_OBJ: SL_MESH_FILE_FORMAT = 2;
#[doc = "\\brief Lists available mesh file formats."]
pub type SL_MESH_FILE_FORMAT = ::std::os::raw::c_uint;
#[doc = " This mode outputs ZED standard depth map that preserves edges and depth accuracy."]
#[doc = " Applications example: Obstacle detection, Automated navigation, People detection, 3D reconstruction, measurements."]
pub const SL_SENSING_MODE_SL_SENSING_MODE_STANDARD: SL_SENSING_MODE = 0;
#[doc = " This mode outputs a smooth and fully dense depth map."]
#[doc = " Applications example: AR/VR, Mixed-reality capture, Image post-processing."]
pub const SL_SENSING_MODE_SL_SENSING_MODE_FILL: SL_SENSING_MODE = 1;
#[doc = "\\brief Lists available depth sensing modes."]
pub type SL_SENSING_MODE = ::std::os::raw::c_uint;
pub const SL_DEPTH_MODE_SL_DEPTH_MODE_NONE: SL_DEPTH_MODE = 0;
#[doc = " This mode does not compute any depth map. Only rectified stereo images will be available."]
pub const SL_DEPTH_MODE_SL_DEPTH_MODE_PERFORMANCE: SL_DEPTH_MODE = 1;
#[doc = " Computation mode optimized for speed."]
pub const SL_DEPTH_MODE_SL_DEPTH_MODE_QUALITY: SL_DEPTH_MODE = 2;
#[doc = " Computation mode designed for challenging areas with untextured surfaces."]
pub const SL_DEPTH_MODE_SL_DEPTH_MODE_ULTRA: SL_DEPTH_MODE = 3;
#[doc = "\\brief Lists available depth computation modes."]
pub type SL_DEPTH_MODE = ::std::os::raw::c_uint;
pub const SL_FLIP_MODE_SL_FLIP_MODE_OFF: SL_FLIP_MODE = 0;
#[doc = "  default behavior."]
pub const SL_FLIP_MODE_SL_FLIP_MODE_ON: SL_FLIP_MODE = 1;
#[doc = " Images and camera sensors data are flipped useful when your camera is mounted upside down."]
pub const SL_FLIP_MODE_SL_FLIP_MODE_AUTO: SL_FLIP_MODE = 2;
#[doc = "\\brief Gives the camera flip mode"]
pub type SL_FLIP_MODE = ::std::os::raw::c_uint;
#[doc = "< copy data from CPU to CPU."]
pub const SL_COPY_TYPE_SL_COPY_TYPE_CPU_CPU: SL_COPY_TYPE = 0;
#[doc = "< copy data from CPU to GPU."]
pub const SL_COPY_TYPE_SL_COPY_TYPE_CPU_GPU: SL_COPY_TYPE = 1;
#[doc = "< copy data from GPU to GPU."]
pub const SL_COPY_TYPE_SL_COPY_TYPE_GPU_GPU: SL_COPY_TYPE = 2;
#[doc = "< copy data from GPU to CPU."]
pub const SL_COPY_TYPE_SL_COPY_TYPE_GPU_CPU: SL_COPY_TYPE = 3;
#[doc = "\\brief List available copy operation on Mat"]
pub type SL_COPY_TYPE = ::std::os::raw::c_uint;
#[doc = "< PNG/ZSTD (lossless) CPU based compression : avg size = 42% (of RAW)."]
pub const SL_SVO_COMPRESSION_MODE_SL_SVO_COMPRESSION_MODE_LOSSLESS: SL_SVO_COMPRESSION_MODE = 0;
#[doc = "< H264(AVCHD) GPU based compression : avg size = 1% (of RAW). Requires a NVIDIA GPU"]
pub const SL_SVO_COMPRESSION_MODE_SL_SVO_COMPRESSION_MODE_H264: SL_SVO_COMPRESSION_MODE = 1;
#[doc = "< H265(HEVC) GPU based compression: avg size = 1% (of RAW). Requires a NVIDIA GPU, Pascal architecture or newer"]
pub const SL_SVO_COMPRESSION_MODE_SL_SVO_COMPRESSION_MODE_H265: SL_SVO_COMPRESSION_MODE = 2;
#[doc = "\\brief Lists available compression modes for SVO recording."]
#[doc = "\\brief SL_SVO_COMPRESSION_MODE_LOSSLESS is an improvement of previous lossless compression (used in ZED Explorer), even if size may be bigger, compression time is much faster."]
pub type SL_SVO_COMPRESSION_MODE = ::std::os::raw::c_uint;
#[doc = "< float 1 channel."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_F32_C1: SL_MAT_TYPE = 0;
#[doc = "< float 2 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_F32_C2: SL_MAT_TYPE = 1;
#[doc = "< float 3 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_F32_C3: SL_MAT_TYPE = 2;
#[doc = "< float 4 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_F32_C4: SL_MAT_TYPE = 3;
#[doc = "< unsigned char 1 channel."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_U8_C1: SL_MAT_TYPE = 4;
#[doc = "< unsigned char 2 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_U8_C2: SL_MAT_TYPE = 5;
#[doc = "< unsigned char 3 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_U8_C3: SL_MAT_TYPE = 6;
#[doc = "< unsigned char 4 channels."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_U8_C4: SL_MAT_TYPE = 7;
#[doc = "< unsigned short 1 channel."]
pub const SL_MAT_TYPE_SL_MAT_TYPE_U16_C1: SL_MAT_TYPE = 8;
#[doc = "\\brief List available Mat formats."]
pub type SL_MAT_TYPE = ::std::os::raw::c_uint;
#[doc = "< PERSON / PERSON_BODY"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_PERSON: SL_OBJECT_SUBCLASS = 0;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BICYCLE: SL_OBJECT_SUBCLASS = 1;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_CAR: SL_OBJECT_SUBCLASS = 2;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_MOTORBIKE: SL_OBJECT_SUBCLASS = 3;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BUS: SL_OBJECT_SUBCLASS = 4;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_TRUCK: SL_OBJECT_SUBCLASS = 5;
#[doc = "< VEHICLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BOAT: SL_OBJECT_SUBCLASS = 6;
#[doc = "< BAG"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BACKPACK: SL_OBJECT_SUBCLASS = 7;
#[doc = "< BAG"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_HANDBAG: SL_OBJECT_SUBCLASS = 8;
#[doc = "< BAG"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_SUITCASE: SL_OBJECT_SUBCLASS = 9;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BIRD: SL_OBJECT_SUBCLASS = 10;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_CAT: SL_OBJECT_SUBCLASS = 11;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_DOG: SL_OBJECT_SUBCLASS = 12;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_HORSE: SL_OBJECT_SUBCLASS = 13;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_SHEEP: SL_OBJECT_SUBCLASS = 14;
#[doc = "< ANIMAL"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_COW: SL_OBJECT_SUBCLASS = 15;
#[doc = "< ELECTRONIC"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_CELLPHONE: SL_OBJECT_SUBCLASS = 16;
#[doc = "< ELECTRONIC"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_LAPTOP: SL_OBJECT_SUBCLASS = 17;
#[doc = "< FRUIT/VEGETABLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_BANANA: SL_OBJECT_SUBCLASS = 18;
#[doc = "< FRUIT/VEGETABLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_APPLE: SL_OBJECT_SUBCLASS = 19;
#[doc = "< FRUIT/VEGETABLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_ORANGE: SL_OBJECT_SUBCLASS = 20;
#[doc = "< FRUIT/VEGETABLE"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_CARROT: SL_OBJECT_SUBCLASS = 21;
#[doc = "< PERSON"]
pub const SL_OBJECT_SUBCLASS_SL_OBJECT_SUBCLASS_PERSON_HEAD: SL_OBJECT_SUBCLASS = 22;
#[doc = "< SPORTSBALL >"]
pub const SL_OBJECT_SUBCLASS_SL_OBJEC_SUBCLASS_SPORTSBALL: SL_OBJECT_SUBCLASS = 23;
#[doc = "\\brief Available object subclass, given as hint, when using object tracking an object can change of OBJECT_SUBCLASS while keeping the same OBJECT_CLASS and id (i.e: frame M: MOTORBIKE, frame N:BICYCLE)"]
pub type SL_OBJECT_SUBCLASS = ::std::os::raw::c_uint;
#[doc = "< The object is staying static."]
pub const SL_OBJECT_ACTION_STATE_SL_OBJECT_ACTION_STATE_IDLE: SL_OBJECT_ACTION_STATE = 0;
#[doc = "< The object is moving."]
pub const SL_OBJECT_ACTION_STATE_SL_OBJECT_ACTION_STATE_MOVING: SL_OBJECT_ACTION_STATE = 1;
#[doc = "\\brief Lists available object action state"]
pub type SL_OBJECT_ACTION_STATE = ::std::os::raw::c_uint;
#[doc = "< Any objects, bounding box based"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_MULTI_CLASS_BOX: SL_DETECTION_MODEL = 0;
#[doc = "< Any objects, bounding box based, more accurate but slower than the base model"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_MULTI_CLASS_BOX_ACCURATE: SL_DETECTION_MODEL = 1;
#[doc = "<  Keypoints based, specific to human skeleton, real time performance even on Jetson or low end GPU cards"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_HUMAN_BODY_FAST: SL_DETECTION_MODEL = 2;
#[doc = "<  Keypoints based, specific to human skeleton, state of the art accuracy, requires powerful GPU"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_HUMAN_BODY_ACCURATE: SL_DETECTION_MODEL = 3;
#[doc = "< Any objects, bounding box based, compromise between accuracy and speed"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_MULTI_CLASS_BOX_MEDIUM: SL_DETECTION_MODEL = 4;
#[doc = "<  Keypoints based, specific to human skeleton, compromise between accuracy and speed"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_HUMAN_BODY_MEDIUM: SL_DETECTION_MODEL = 5;
#[doc = "<  Bounding Box detector specialized in person heads, particulary well suited for crowded environement, the person localization is also improved"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_PERSON_HEAD_BOX: SL_DETECTION_MODEL = 6;
#[doc = "< For external inference, using your own custom model and/or frameworks. This mode disable the internal inference engine, the 2D bounding box detection must be provided"]
pub const SL_DETECTION_MODEL_SL_DETECTION_MODEL_CUSTOM_BOX_OBJECTS: SL_DETECTION_MODEL = 7;
#[doc = "\\brief List available models for detection"]
pub type SL_DETECTION_MODEL = ::std::os::raw::c_uint;
#[doc = " \\brief 18  keypoint model of COCO 18."]
#[doc = " \\note local keypoint angle and position are not available with this format"]
pub const SL_BODY_FORMAT_SL_BODY_FORMAT_POSE_18: SL_BODY_FORMAT = 0;
#[doc = " \\brief 34 keypoint model."]
#[doc = " \\note local keypoint angle and position are available"]
#[doc = " \\warning The SDK will automatically enable fitting."]
pub const SL_BODY_FORMAT_SL_BODY_FORMAT_POSE_34: SL_BODY_FORMAT = 1;
#[doc = "\\brief Lists of supported skeleton body model"]
pub type SL_BODY_FORMAT = ::std::os::raw::c_uint;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_NOSE: SL_BODY_PARTS_POSE_18 = 0;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_NECK: SL_BODY_PARTS_POSE_18 = 1;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_SHOULDER: SL_BODY_PARTS_POSE_18 = 2;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_ELBOW: SL_BODY_PARTS_POSE_18 = 3;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_WRIST: SL_BODY_PARTS_POSE_18 = 4;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_SHOULDER: SL_BODY_PARTS_POSE_18 = 5;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_ELBOW: SL_BODY_PARTS_POSE_18 = 6;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_WRIST: SL_BODY_PARTS_POSE_18 = 7;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_HIP: SL_BODY_PARTS_POSE_18 = 8;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_KNEE: SL_BODY_PARTS_POSE_18 = 9;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_ANKLE: SL_BODY_PARTS_POSE_18 = 10;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_HIP: SL_BODY_PARTS_POSE_18 = 11;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_KNEE: SL_BODY_PARTS_POSE_18 = 12;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_ANKLE: SL_BODY_PARTS_POSE_18 = 13;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_EYE: SL_BODY_PARTS_POSE_18 = 14;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_EYE: SL_BODY_PARTS_POSE_18 = 15;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_RIGHT_EAR: SL_BODY_PARTS_POSE_18 = 16;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LEFT_EAR: SL_BODY_PARTS_POSE_18 = 17;
pub const SL_BODY_PARTS_POSE_18_SL_BODY_PARTS_POSE_18_LAST: SL_BODY_PARTS_POSE_18 = 18;
#[doc = " \\brief semantic of human body parts and order of \\ref ObjectData::keypoint."]
pub type SL_BODY_PARTS_POSE_18 = ::std::os::raw::c_uint;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_PELVIS: SL_BODY_PARTS_POSE_34 = 0;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_NAVAL_SPINE: SL_BODY_PARTS_POSE_34 = 1;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_CHEST_SPINE: SL_BODY_PARTS_POSE_34 = 2;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_NECK: SL_BODY_PARTS_POSE_34 = 3;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_CLAVICLE: SL_BODY_PARTS_POSE_34 = 4;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_SHOULDER: SL_BODY_PARTS_POSE_34 = 5;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_ELBOW: SL_BODY_PARTS_POSE_34 = 6;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_WRIST: SL_BODY_PARTS_POSE_34 = 7;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_HAND: SL_BODY_PARTS_POSE_34 = 8;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_HANDTIP: SL_BODY_PARTS_POSE_34 = 9;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_THUMB: SL_BODY_PARTS_POSE_34 = 10;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_CLAVICLE: SL_BODY_PARTS_POSE_34 = 11;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_SHOULDER: SL_BODY_PARTS_POSE_34 = 12;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_ELBO: SL_BODY_PARTS_POSE_34 = 13;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_WRIST: SL_BODY_PARTS_POSE_34 = 14;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_HAND: SL_BODY_PARTS_POSE_34 = 15;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_HANDTIP: SL_BODY_PARTS_POSE_34 = 16;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_THUMB: SL_BODY_PARTS_POSE_34 = 17;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_HIP: SL_BODY_PARTS_POSE_34 = 18;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_KNEE: SL_BODY_PARTS_POSE_34 = 19;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_ANKLE: SL_BODY_PARTS_POSE_34 = 20;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_FOOT: SL_BODY_PARTS_POSE_34 = 21;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_HIP: SL_BODY_PARTS_POSE_34 = 22;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_KNEE: SL_BODY_PARTS_POSE_34 = 23;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_ANKLE: SL_BODY_PARTS_POSE_34 = 24;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_FOOT: SL_BODY_PARTS_POSE_34 = 25;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_HEAD: SL_BODY_PARTS_POSE_34 = 26;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_NOSE: SL_BODY_PARTS_POSE_34 = 27;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_EYE: SL_BODY_PARTS_POSE_34 = 28;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_EAR: SL_BODY_PARTS_POSE_34 = 29;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_EYE: SL_BODY_PARTS_POSE_34 = 30;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_EAR: SL_BODY_PARTS_POSE_34 = 31;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LEFT_HEEL: SL_BODY_PARTS_POSE_34 = 32;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_RIGHT_HEEL: SL_BODY_PARTS_POSE_34 = 33;
pub const SL_BODY_PARTS_POSE_34_SL_BODY_PARTS_POSE_34_LAST: SL_BODY_PARTS_POSE_34 = 34;
#[doc = " \\brief semantic of human body parts and order of \\ref ObjectData::keypoint for BODY_FORMAT::POSE_34."]
pub type SL_BODY_PARTS_POSE_34 = ::std::os::raw::c_uint;
#[doc = " \\brief Resolution"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Resolution {
    pub width: ::std::os::raw::c_longlong,
    pub height: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_SL_Resolution() {
    assert_eq!(
        ::std::mem::size_of::<SL_Resolution>(),
        16usize,
        concat!("Size of: ", stringify!(SL_Resolution))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Resolution>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_Resolution))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Resolution>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Resolution),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Resolution>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Resolution),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "Struct containing all parameters passed to the SDK when initializing the ZED."]
#[doc = "These parameters will be fixed for the whole execution life time of the camera."]
#[doc = "For more details, see the InitParameters class in the SDK API documentation:"]
#[doc = "https://www.stereolabs.com/docs/api/structsl_1_1InitParameters.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_InitParameters {
    #[doc = "The SDK can handle different input types:"]
    #[doc = "- Select a camera by its ID (/dev/video<i>X</i> on Linux, and 0 to N cameras connected on Windows)"]
    #[doc = "- Select a camera by its serial number"]
    #[doc = "- Open a recorded sequence in the SVO file format"]
    #[doc = "- Open a streaming camera from its IP address and port"]
    #[doc = ""]
    #[doc = "This parameter allows you to select to desired input."]
    pub input_type: SL_INPUT_TYPE,
    #[doc = "Define the chosen camera resolution. Small resolutions offer higher framerate and lower computation time (SL_RESOLUTION).\\n"]
    #[doc = "In most situations, the \\ref RESOLUTION \"RESOLUTION_HD720\" at 60 fps is the best balance between image quality and framerate.\\n"]
    #[doc = "Available resolutions are listed here: \\ref RESOLUTION."]
    #[doc = "\\n default : \\ref RESOLUTION \"RESOLUTION_HD720\""]
    pub resolution: SL_RESOLUTION,
    #[doc = "Requested camera frame rate. If set to 0, the highest FPS of the specified \\ref camera_resolution will be used.\\n"]
    #[doc = "See \\ref RESOLUTION for a list of supported framerates."]
    #[doc = "\\n default : 0"]
    #[doc = "\\note If the requested camera_fps is unsupported, the closest available FPS will be used."]
    pub camera_fps: ::std::os::raw::c_int,
    #[doc = "Id of the Camera."]
    pub camera_device_id: ::std::os::raw::c_int,
    #[doc = "If you are using the camera upside down, setting this parameter to FLIP_MODE_ON will cancel its rotation. The images will be horizontally flipped."]
    #[doc = "\\n default : FLIP_MODE_AUTO"]
    #[doc = " From ZED SDK 3.2 a new FLIP_MODE enum was introduced to add the automatic flip mode detection based on the IMU gravity detection. This only works for ZED-M or ZED2 cameras."]
    pub camera_image_flip: SL_FLIP_MODE,
    #[doc = "At initialization, the \\ref Camera runs a self-calibration process that corrects small offsets from the device's factory calibration.\\n"]
    #[doc = "A drawback is that calibration parameters will slightly change from one run to another, which can be an issue for repeatability.\\n"]
    #[doc = "If set to true, self-calibration will be disabled and calibration parameters won't be optimized.\\n"]
    #[doc = "default : false"]
    #[doc = "\\note In most situations, self calibration should remain enabled."]
    #[doc = "\\note You can also trigger the self-calibration at anytime after open() by calling \\ref Camera::UpdateSelfCalibration(), even if this parameter is set to true."]
    #[doc = ""]
    pub camera_disable_self_calib: bool,
    #[doc = "By default, the SDK only computes a single depth map, aligned with the left camera image.\\n"]
    #[doc = "This parameter allows you to enable the \\ref MEASURE \"MEASURE_DEPTH_RIGHT\" and other \\ref MEASURE \"MEASURE_<XXX>_RIGHT\" at the cost of additional computation time.\\n"]
    #[doc = ""]
    #[doc = "For example, mixed reality pass-through applications require one depth map per eye, so this parameter can be activated."]
    #[doc = "\\n default : false"]
    pub enable_right_side_measure: bool,
    #[doc = "When playing back an SVO file, each call to \\ref Camera::grab() will extract a new frame and use it.\\n"]
    #[doc = "However, this ignores the real capture rate of the images saved in the SVO file.\\n"]
    #[doc = "Enabling this parameter will bring the SDK closer to a real simulation when playing back a file by using the images' timestamps. However, calls to \\ref Camera::grab() will return an error when trying to play too fast, and frames will be dropped when playing too slowly."]
    #[doc = ""]
    #[doc = "\\n default : false"]
    pub svo_real_time_mode: bool,
    #[doc = "The SDK offers several \\ref DEPTH_MODE options offering various levels of performance and accuracy."]
    #[doc = "\\n This parameter allows you to set the \\ref DEPTH_MODE that best matches your needs."]
    #[doc = "\\n default : \\ref DEPTH_MODE \"DEPTH_MODE_PERFORMANCE\""]
    pub depth_mode: SL_DEPTH_MODE,
    #[doc = "Regions of the generated depth map can oscillate from one frame to another. These oscillations result from a lack of texture (too homogeneous) on an object and by image noise."]
    #[doc = "\\n This parameter enables a stabilization filter that reduces these oscillations."]
    #[doc = "\\n default : true"]
    #[doc = "\\note The stabilization uses the positional tracking to increase its accuracy, so the Positional Tracking module will be enabled automatically when set to true.\\n"]
    pub depth_stabilization: bool,
    #[doc = "This parameter allows you to specify the minimum depth value (from the camera) that will be computed, measured in the \\ref UNIT you define."]
    #[doc = "\\n In stereovision (the depth technology used by the camera), looking for closer depth values can have a slight impact on performance and memory consumption."]
    #[doc = "\\n On most of modern GPUs, performance impact will be low. However, the impact of memory footprint will be visible."]
    #[doc = "\\n In cases of limited computation power, increasing this value can provide better performance."]
    #[doc = "\\n default : (-1) corresponding to 700 mm for a ZED/ZED2 and 300 mm for ZED Mini."]
    #[doc = ""]
    #[doc = "\\note With a ZED camera you can decrease this value to 300 mm whereas you can set it to 100 mm using a ZED Mini and 200 mm for a ZED2. In any case this value cannot be greater than 3 meters."]
    #[doc = "\\note Specific value (0) : This will set the depth minimum distance to the minimum authorized value :"]
    #[doc = "- 300mm for ZED"]
    #[doc = "- 100mm for ZED-M"]
    #[doc = "- 200mm for ZED2"]
    pub depth_minimum_distance: f32,
    #[doc = "Defines the current maximum distance that can be computed in the defined \\ref UNIT."]
    #[doc = "When estimating the depth, the SDK uses this upper limit to turn higher values into \\ref TOO_FAR ones."]
    #[doc = ""]
    #[doc = "\\note Changing this value has no impact on performance and doesn't affect the positional tracking nor the spatial mapping. (Only the depth, point cloud, normals)"]
    pub depth_maximum_distance: f32,
    #[doc = "This parameter allows you to select the unit to be used for all metric values of the SDK. (depth, point cloud, tracking, mesh, and others) (SL_UNIT)."]
    #[doc = "\\n default : \\ref UNIT \"UNIT_MILLIMETER\""]
    pub coordinate_unit: SL_UNIT,
    #[doc = "Positional tracking, point clouds and many other features require a given \\ref COORDINATE_SYSTEM to be used as reference."]
    #[doc = "This parameter allows you to select the \\ref COORDINATE_SYSTEM used by the \\ref Camera to return its measures."]
    #[doc = "\\n This defines the order and the direction of the axis of the coordinate system."]
    #[doc = "\\n default : \\ref COORDINATE_SYSTEM \"COORDINATE_SYSTEM_IMAGE\""]
    pub coordinate_system: SL_COORDINATE_SYSTEM,
    #[doc = "By default the SDK will use the most powerful NVIDIA graphics card found."]
    #[doc = "However, when running several applications, or using several cameras at the same time, splitting the load over available GPUs can be useful."]
    #[doc = "This parameter allows you to select the GPU used by the \\ref Camera using an ID from 0 to n-1 GPUs in your PC."]
    #[doc = "\\n default : -1"]
    #[doc = "\\note A non-positive value will search for all CUDA capable devices and select the most powerful."]
    pub sdk_gpu_id: ::std::os::raw::c_int,
    #[doc = "This parameter allows you to enable the verbosity of the SDK to get a variety of runtime information in the console."]
    #[doc = "When developing an application, enabling verbose mode can help you understand the current SDK behavior."]
    #[doc = "\\n However, this might not be desirable in a shipped version."]
    #[doc = "\\n default : false"]
    #[doc = "\\note The verbose messages can also be exported into a log file. See \\ref sdk_verbose_log_file for more."]
    pub sdk_verbose: ::std::os::raw::c_int,
    #[doc = "Force the motion sensors opening of the ZED 2 / ZED-M to open the camera."]
    #[doc = "\\n default : false."]
    #[doc = "\\n If set to false, the SDK will try to <b>open and use</b> the IMU (second USB device on USB2.0) and will open the camera successfully even if the sensors failed to open."]
    #[doc = "\\n This can be used for example when using a USB3.0 only extension cable (some fiber extension for example)."]
    #[doc = "\\n This parameter only impacts the LIVE mode."]
    #[doc = "\\n If set to true, the camera will fail to open if the sensors cannot be opened. This parameter should be used when the IMU data must be available, such as Object Detection module or when the gravity is needed."]
    #[doc = "\\note This setting is not taken into account for ZED camera since it does not include sensors."]
    pub sensors_required: bool,
    #[doc = "Enable or Disable the Enhanced Contrast Technology, to improve image quality."]
    #[doc = "\\n default : true."]
    #[doc = "\\n If set to true, image enhancement will be activated in camera ISP. Otherwise, the image will not be enhanced by the IPS."]
    #[doc = "\\n This only works for firmware version starting from 1523 and up."]
    pub enable_image_enhancement: bool,
    #[doc = "Define a timeout in seconds after which an error is reported if the \\ref open() command fails."]
    #[doc = "Set to '-1' to try to open the camera endlessly without returning error in case of failure."]
    #[doc = "Set to '0' to return error in case of failure at the first attempt."]
    #[doc = "\\n This parameter only impacts the LIVE mode."]
    pub open_timeout_sec: f32,
}
#[test]
fn bindgen_test_layout_SL_InitParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_InitParameters>(),
        64usize,
        concat!("Size of: ", stringify!(SL_InitParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_InitParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_InitParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).input_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(input_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).resolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).camera_fps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(camera_fps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).camera_device_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(camera_device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).camera_image_flip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(camera_image_flip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).camera_disable_self_calib as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(camera_disable_self_calib)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).enable_right_side_measure as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(enable_right_side_measure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).svo_real_time_mode as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(svo_real_time_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).depth_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(depth_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).depth_stabilization as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(depth_stabilization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).depth_minimum_distance as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(depth_minimum_distance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).depth_maximum_distance as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(depth_maximum_distance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).coordinate_unit as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(coordinate_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).coordinate_system as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(coordinate_system)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).sdk_gpu_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(sdk_gpu_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_InitParameters>())).sdk_verbose as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(sdk_verbose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).sensors_required as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(sensors_required)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).enable_image_enhancement as *const _
                as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(enable_image_enhancement)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_InitParameters>())).open_timeout_sec as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_InitParameters),
            "::",
            stringify!(open_timeout_sec)
        )
    );
}
#[doc = "Parameters that define the behavior of the grab."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_RuntimeParameters {
    #[doc = "Defines the algorithm used for depth map computation, more info : \\ref SENSING_MODE definition."]
    #[doc = "\\n default : \\ref SENSING_MODE_STANDARD"]
    pub sensing_mode: SL_SENSING_MODE,
    #[doc = "Provides 3D measures (point cloud and normals) in the desired reference frame (default is REFERENCE_FRAME_CAMERA)"]
    #[doc = "\\n default : \\ref REFERENCE_FRAME_CAMERA"]
    pub reference_frame: SL_REFERENCE_FRAME,
    #[doc = "Defines if the depth map should be computed."]
    #[doc = "\\n If false, only the images are available."]
    #[doc = "\\n default : true"]
    pub enable_depth: bool,
    #[doc = "Threshold to reject depth values based on their confidence."]
    #[doc = "\\n Each depth pixel has a corresponding confidence. (\\ref MEASURE \"MEASURE_CONFIDENCE\"), the confidence range is [1,100]."]
    #[doc = "\\n By default, the confidence threshold is set at 100, meaning that no depth pixel will be rejected."]
    #[doc = "\\n Decreasing this value will remove depth data from both objects edges and low textured areas, to keep only confident depth estimation data."]
    pub confidence_threshold: ::std::os::raw::c_int,
    #[doc = "Threshold to reject depth values based on their texture confidence."]
    #[doc = "\\n The texture confidence range is [1,100]."]
    #[doc = "\\n By default, the texture confidence threshold is set at 100, meaning that no depth pixel will be rejected."]
    #[doc = "\\n Decreasing this value will remove depth data from image areas which are uniform."]
    pub texture_confidence_threshold: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_RuntimeParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_RuntimeParameters>(),
        20usize,
        concat!("Size of: ", stringify!(SL_RuntimeParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_RuntimeParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_RuntimeParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_RuntimeParameters>())).sensing_mode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_RuntimeParameters),
            "::",
            stringify!(sensing_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_RuntimeParameters>())).reference_frame as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_RuntimeParameters),
            "::",
            stringify!(reference_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_RuntimeParameters>())).enable_depth as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_RuntimeParameters),
            "::",
            stringify!(enable_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_RuntimeParameters>())).confidence_threshold as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_RuntimeParameters),
            "::",
            stringify!(confidence_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_RuntimeParameters>())).texture_confidence_threshold
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_RuntimeParameters),
            "::",
            stringify!(texture_confidence_threshold)
        )
    );
}
#[doc = "Properties of a camera."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_DeviceProperties {
    #[doc = "the camera state"]
    pub camera_state: SL_CAMERA_STATE,
    #[doc = "the camera id"]
    pub id: ::std::os::raw::c_int,
    #[doc = "the camera model"]
    pub camera_model: SL_MODEL,
    #[doc = "the camera serial number"]
    #[doc = "\\n Not provided for Windows"]
    pub sn: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_DeviceProperties() {
    assert_eq!(
        ::std::mem::size_of::<SL_DeviceProperties>(),
        16usize,
        concat!("Size of: ", stringify!(SL_DeviceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_DeviceProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_DeviceProperties))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_DeviceProperties>())).camera_state as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_DeviceProperties),
            "::",
            stringify!(camera_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_DeviceProperties>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_DeviceProperties),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_DeviceProperties>())).camera_model as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_DeviceProperties),
            "::",
            stringify!(camera_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_DeviceProperties>())).sn as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_DeviceProperties),
            "::",
            stringify!(sn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_CameraParameters {
    #[doc = "< Focal length in pixels along x axis."]
    pub fx: f32,
    #[doc = "< Focal length in pixels along y axis."]
    pub fy: f32,
    #[doc = "< Optical center along x axis, defined in pixels (usually close to width/2)."]
    pub cx: f32,
    #[doc = "< Optical center along y axis, defined in pixels (usually close to height/2)."]
    pub cy: f32,
    #[doc = "< Distortion factor : [ k1, k2, p1, p2, k3 ]. Radial (k1,k2,k3) and Tangential (p1,p2) distortion."]
    pub disto: [f64; 5usize],
    #[doc = "< Vertical field of view, in degrees."]
    pub v_fov: f32,
    #[doc = "< Horizontal field of view, in degrees."]
    pub h_fov: f32,
    #[doc = "< Diagonal field of view, in degrees."]
    pub d_fov: f32,
    pub image_size: SL_Resolution,
}
#[test]
fn bindgen_test_layout_SL_CameraParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_CameraParameters>(),
        88usize,
        concat!("Size of: ", stringify!(SL_CameraParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_CameraParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_CameraParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).fx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(fx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).fy as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(fy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).cx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).cy as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).disto as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(disto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).v_fov as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(v_fov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).h_fov as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(h_fov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).d_fov as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(d_fov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CameraParameters>())).image_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CameraParameters),
            "::",
            stringify!(image_size)
        )
    );
}
#[doc = "Holds calibration information about the current ZED's hardware, including per-sensor calibration and offsets between the two sensors."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_CalibrationParameters {
    #[doc = "Intrinsic parameters of the left camera"]
    pub left_cam: SL_CameraParameters,
    #[doc = "Intrinsic parameters of the right camera"]
    pub right_cam: SL_CameraParameters,
    #[doc = "Left to Right camera rotation, expressed in user coordinate system and unit (defined by InitParameters)."]
    pub rotation: SL_Vector4,
    #[doc = "Left to Right camera translation, expressed in user coordinate system and unit (defined by InitParameters)."]
    pub translation: SL_Vector3,
}
#[test]
fn bindgen_test_layout_SL_CalibrationParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_CalibrationParameters>(),
        208usize,
        concat!("Size of: ", stringify!(SL_CalibrationParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_CalibrationParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_CalibrationParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CalibrationParameters>())).left_cam as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CalibrationParameters),
            "::",
            stringify!(left_cam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CalibrationParameters>())).right_cam as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CalibrationParameters),
            "::",
            stringify!(right_cam)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CalibrationParameters>())).rotation as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CalibrationParameters),
            "::",
            stringify!(rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CalibrationParameters>())).translation as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CalibrationParameters),
            "::",
            stringify!(translation)
        )
    );
}
#[doc = "\\brief Structure containing information about a single sensor available in the current device"]
#[doc = "\\note This object is meant to be used as a read - only container, editing any of its fields won't impact the SDK."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_SensorParameters {
    pub type_: SL_SENSOR_TYPE,
    #[doc = " The type of the sensor as \\ref DEVICE_SENSORS (SL_SENSOR_TYPE)"]
    pub resolution: f32,
    #[doc = " The resolution of the sensor."]
    pub sampling_rate: f32,
    #[doc = " The sampling rate (or ODR) of the sensor."]
    pub range: SL_Vector2,
    #[doc = " The range values of the sensor. MIN: \"range.x\", MAX: \"range.y\""]
    pub noise_density: f32,
    #[doc = " also known as white noise, given as continous (frequency independant). Units will be expressed in sensor_unit/squared_root(Hz). \"NAN\" if the information is not available"]
    pub random_walk: f32,
    #[doc = " derived from the Allan Variance, given as continous (frequency independant). Units will be expressed in sensor_unit/s/squared_root(Hz).\"NAN\" if the information is not available"]
    pub sensor_unit: SL_SENSORS_UNIT,
    #[doc = " The string relative to the measurement unit of the sensor (SL_SENSORS_UNIT)."]
    pub is_available: bool,
}
#[test]
fn bindgen_test_layout_SL_SensorParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_SensorParameters>(),
        36usize,
        concat!("Size of: ", stringify!(SL_SensorParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_SensorParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_SensorParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorParameters>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorParameters>())).resolution as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorParameters>())).sampling_rate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(sampling_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorParameters>())).range as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorParameters>())).noise_density as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(noise_density)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorParameters>())).random_walk as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(random_walk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_SensorParameters>())).sensor_unit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(sensor_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorParameters>())).is_available as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorParameters),
            "::",
            stringify!(is_available)
        )
    );
}
#[doc = "Structure containing information about all the sensors available in the current device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_SensorsConfiguration {
    #[doc = "The firmware version of the sensor module, 0 if no sensors are available (ZED camera model)."]
    pub firmware_version: ::std::os::raw::c_uint,
    #[doc = "IMU to Left camera rotation (quaternion)."]
    pub camera_ium_rotation: SL_Vector4,
    #[doc = "IMU to Left camera translation (SL_float3)."]
    pub camera_imu_translation: SL_Vector3,
    #[doc = "Magnetometer to IMU rotation. That contains rotation between IMU frame and magnetometer frame."]
    pub ium_magnetometer_rotation: SL_Vector4,
    #[doc = "Magnetometer to IMU translation. That contains translation between IMU frame and magnetometer frame."]
    pub ium_magnetometer_translation: SL_Vector3,
    #[doc = "Configuration of the accelerometer device"]
    pub accelerometer_parameters: SL_SensorParameters,
    #[doc = "Configuration of the gyroscope device"]
    pub gyroscope_parameters: SL_SensorParameters,
    #[doc = "Configuration of the magnetometer device"]
    pub magnetometer_parameters: SL_SensorParameters,
    #[doc = "Configuration of the barometer device"]
    pub barometer_parameters: SL_SensorParameters,
}
#[test]
fn bindgen_test_layout_SL_SensorsConfiguration() {
    assert_eq!(
        ::std::mem::size_of::<SL_SensorsConfiguration>(),
        204usize,
        concat!("Size of: ", stringify!(SL_SensorsConfiguration))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_SensorsConfiguration>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_SensorsConfiguration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).firmware_version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(firmware_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).camera_ium_rotation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(camera_ium_rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).camera_imu_translation as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(camera_imu_translation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).ium_magnetometer_rotation
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(ium_magnetometer_rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).ium_magnetometer_translation
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(ium_magnetometer_translation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).accelerometer_parameters as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(accelerometer_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).gyroscope_parameters as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(gyroscope_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).magnetometer_parameters as *const _
                as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(magnetometer_parameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SensorsConfiguration>())).barometer_parameters as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SensorsConfiguration),
            "::",
            stringify!(barometer_parameters)
        )
    );
}
#[doc = "Parameters for positional tracking initialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_PositionalTrackingParameters {
    #[doc = "Rotation of the camera in the world frame when the camera is started. By default, it should be identity."]
    pub initial_world_rotation: SL_Quaternion,
    #[doc = "Position of the camera in the world frame when the camera is started. By default, it should be identity."]
    pub initial_world_position: SL_Vector3,
    #[doc = "This mode enables the camera to remember its surroundings. This helps correct positional tracking drift, and can be helpful for positioning"]
    #[doc = "different cameras relative to one other in space."]
    #[doc = "\\n default: true"]
    #[doc = ""]
    #[doc = "\\warning: This mode requires more resources to run, but greatly improves tracking accuracy. We recommend leaving it on by default."]
    pub enable_area_memory: bool,
    #[doc = "This mode enables smooth pose correction for small drift correction."]
    #[doc = "\\n default: false"]
    pub enable_pose_smothing: bool,
    #[doc = "This mode initializes the tracking to be aligned with the floor plane to better position the camera in space."]
    #[doc = "\\n default: false"]
    #[doc = "\\note This launches floor plane detection in the background until a suitable floor plane is found."]
    #[doc = "The tracking is in POSITIONAL_TRACKING_STATE_SEARCHING state."]
    #[doc = ""]
    #[doc = "\\warning This features work best with the ZED-M since it needs an IMU to classify the floor."]
    #[doc = " The ZED needs to look at the floor during initialization for optimum results."]
    pub set_floor_as_origin: bool,
    #[doc = "This setting allows you define the camera as static. If true, it will not move in the environment. This allows you to set its position using initial_world_transform."]
    #[doc = "\\n All SDK functionalities requiring positional tracking will be enabled."]
    #[doc = "\\n Camera::getPosition() will return the value set as initial_world_transform for the PATH, and identity as the POSE."]
    pub set_as_static: bool,
    #[doc = "This setting allows you to enable or disable IMU fusion. When set to false, only the optical odometry will be used."]
    #[doc = "\\n default: true"]
    #[doc = "\\note This setting has no impact on the tracking of a ZED camera; only the ZED Mini uses a built-in IMU."]
    pub enable_imu_fusion: bool,
}
#[test]
fn bindgen_test_layout_SL_PositionalTrackingParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_PositionalTrackingParameters>(),
        36usize,
        concat!("Size of: ", stringify!(SL_PositionalTrackingParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_PositionalTrackingParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_PositionalTrackingParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).initial_world_rotation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(initial_world_rotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).initial_world_position
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(initial_world_position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).enable_area_memory
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(enable_area_memory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).enable_pose_smothing
                as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(enable_pose_smothing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).set_floor_as_origin
                as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(set_floor_as_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).set_as_static as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(set_as_static)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_PositionalTrackingParameters>())).enable_imu_fusion
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_PositionalTrackingParameters),
            "::",
            stringify!(enable_imu_fusion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_SpatialMappingParameters {
    #[doc = "\\brief Spatial mapping resolution in meters. Should fit \\ref allowed_resolution (Default is 0.05f)."]
    pub resolution_meter: f32,
    #[doc = "\\brief Depth range in meters."]
    #[doc = "Can be different from the value set by \\ref setDepthMaxRangeValue."]
    #[doc = "Set to 0 by default. In this case, the range is computed from resolution_meter"]
    #[doc = "and from the current internal parameters to fit your application."]
    pub range_meter: f32,
    #[doc = "\\brief Set to true if you want to be able to apply the texture to your mesh after its creation."]
    #[doc = ""]
    #[doc = "\\note This option will consume more memory."]
    #[doc = "\\note This option is only available for \\ref SPATIAL_MAP_TYPE_MESH"]
    pub save_texture: bool,
    #[doc = "\\brief Set to false if you want to ensure consistency between the mesh and its inner chunk data (default is false)."]
    #[doc = ""]
    #[doc = "\\note Updating the mesh is time-consuming. Setting this to true results in better performance."]
    pub use_chunk_only: bool,
    #[doc = "\\brief The maximum CPU memory (in MB) allocated for the meshing process (default is 2048)."]
    pub max_memory_usage: ::std::os::raw::c_int,
    #[doc = "\\brief Specify if the order of the vertices of the triangles needs to be inverted. If your display process does not handle front and back face culling, you can use this to correct it."]
    #[doc = ""]
    #[doc = "\\note This option is only available for \\ref SPATIAL_MAP_TYPE_MESH"]
    pub reverse_vertex_order: bool,
    #[doc = "\\brief The type of spatial map to be created. This dictates the format that will be used for the mapping(e.g. mesh, point cloud). See \\ref SPATIAL_MAP_TYPE"]
    pub map_type: SL_SPATIAL_MAP_TYPE,
}
#[test]
fn bindgen_test_layout_SL_SpatialMappingParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_SpatialMappingParameters>(),
        24usize,
        concat!("Size of: ", stringify!(SL_SpatialMappingParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_SpatialMappingParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_SpatialMappingParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).resolution_meter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(resolution_meter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).range_meter as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(range_meter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).save_texture as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(save_texture)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).use_chunk_only as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(use_chunk_only)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).max_memory_usage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(max_memory_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).reverse_vertex_order as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(reverse_vertex_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_SpatialMappingParameters>())).map_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_SpatialMappingParameters),
            "::",
            stringify!(map_type)
        )
    );
}
#[doc = "Contains positional tracking data which gives the position and orientation of the ZED in 3D space."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Pose {
    pub position: SL_Vector3,
    pub rotation: SL_Vector4,
}
#[test]
fn bindgen_test_layout_SL_Pose() {
    assert_eq!(
        ::std::mem::size_of::<SL_Pose>(),
        28usize,
        concat!("Size of: ", stringify!(SL_Pose))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Pose>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Pose))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Pose>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Pose),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Pose>())).rotation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Pose),
            "::",
            stringify!(rotation)
        )
    );
}
#[doc = "Contains all tracking data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_TrackingData {
    pub zed_path_transform: SL_Pose,
    pub zed_world_transform: SL_Pose,
    pub offset_zed_world_transform: SL_Pose,
    pub tracking_state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_TrackingData() {
    assert_eq!(
        ::std::mem::size_of::<SL_TrackingData>(),
        88usize,
        concat!("Size of: ", stringify!(SL_TrackingData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_TrackingData>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_TrackingData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TrackingData>())).zed_path_transform as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TrackingData),
            "::",
            stringify!(zed_path_transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TrackingData>())).zed_world_transform as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TrackingData),
            "::",
            stringify!(zed_world_transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_TrackingData>())).offset_zed_world_transform as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TrackingData),
            "::",
            stringify!(offset_zed_world_transform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_TrackingData>())).tracking_state as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_TrackingData),
            "::",
            stringify!(tracking_state)
        )
    );
}
#[doc = " Set the batch trajectory parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_BatchParameters {
    #[doc = "\\brief Defines if the Batch option in the object detection module is enabled. Batch queueing system provides:"]
    #[doc = "  - Deep-Learning based re-identification"]
    #[doc = "  - Trajectory smoothing and filtering"]
    #[doc = "\\note To activate this option, enable must be set to true."]
    pub enable: bool,
    #[doc = "\\brief Max retention time in seconds of a detected object. After this time, the same object will mostly have a different ID."]
    pub id_retention_time: f32,
    #[doc = "\\brief Trajectories will be output in batch with the desired latency in seconds."]
    #[doc = "During this waiting time, re-identification of objects is done in the background."]
    #[doc = "Specifying a short latency will limit the search ( falling in timeout) for previously seen object IDs but will be closer to real time output."]
    #[doc = "Specifying a long latency will reduce the change of timeout in Re-ID but increase difference with live output."]
    pub latency: f32,
}
#[test]
fn bindgen_test_layout_SL_BatchParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_BatchParameters>(),
        12usize,
        concat!("Size of: ", stringify!(SL_BatchParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_BatchParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_BatchParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_BatchParameters>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BatchParameters),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_BatchParameters>())).id_retention_time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BatchParameters),
            "::",
            stringify!(id_retention_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_BatchParameters>())).latency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_BatchParameters),
            "::",
            stringify!(latency)
        )
    );
}
#[doc = "Sets the object detection parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_ObjectDetectionParameters {
    #[doc = "\\brief Defines if the object detection is synchronized to the image or runs in a separate thread."]
    #[doc = "If set to true, the detection is run for every grab, otherwise, the thread runs at its own speed, which can lead to new detection once in a while."]
    pub image_sync: bool,
    #[doc = "\\brief Defines if the object detection will track objects across images flow"]
    pub enable_tracking: bool,
    #[doc = "\\brief Defines if the mask object will be computed"]
    pub enable_mask_output: bool,
    #[doc = "\\brief Enable human pose estimation with skeleton keypoints output (SL_DETECTION_MODEL)."]
    pub model: SL_DETECTION_MODEL,
    #[doc = "\\brief Defines if the body fitting will be applied"]
    pub enable_body_fitting: bool,
    #[doc = " \\brief Defines the body format outputed by the sdk when \\ref retrieveObjects is called."]
    #[doc = ""]
    pub body_format: SL_BODY_FORMAT,
    #[doc = "\\brief Defines a upper depth range for detections."]
    #[doc = " \\n Defined in \\ref UNIT set at \\ref SL_Camera::open."]
    #[doc = " \\n Default value is set to \\ref SL_Initparameters::depth_maximum_distance (can not be higher)."]
    pub max_range: f32,
    #[doc = "\\brief Batching system parameters."]
    #[doc = "Batching system (introduced in 3.5) performs short-term re-identification with deep learning and trajectories filtering."]
    #[doc = " \\n BatchParameters::enable need to be true to use this feature (by default disabled)"]
    pub batch_parameters: SL_BatchParameters,
}
#[test]
fn bindgen_test_layout_SL_ObjectDetectionParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_ObjectDetectionParameters>(),
        32usize,
        concat!("Size of: ", stringify!(SL_ObjectDetectionParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_ObjectDetectionParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_ObjectDetectionParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).image_sync as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(image_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).enable_tracking as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(enable_tracking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).enable_mask_output as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(enable_mask_output)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).model as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).enable_body_fitting as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(enable_body_fitting)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).body_format as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(body_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).max_range as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(max_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionParameters>())).batch_parameters as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionParameters),
            "::",
            stringify!(batch_parameters)
        )
    );
}
#[doc = "< For people detection"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_PERSON: SL_OBJECT_CLASS = 0;
#[doc = "< For vehicle detection. It can be cars, trucks, buses, motorcycles etc"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_VEHICLE: SL_OBJECT_CLASS = 1;
#[doc = "< For bag detection (backpack, handbag, suitcase)"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_BAG: SL_OBJECT_CLASS = 2;
#[doc = "< For animal detection (cow, sheep, horse, dog, cat, bird, etc)"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_ANIMAL: SL_OBJECT_CLASS = 3;
#[doc = "< For electronic device detection (cellphone, laptop, etc)"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_ELECTRONICS: SL_OBJECT_CLASS = 4;
#[doc = "<  For fruit and vegetable detection (banana, apple, orange, carrot, etc)"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_FRUIT_VEGETABLE: SL_OBJECT_CLASS = 5;
#[doc = "<  For sport related objects (sports ball etc)"]
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_SPORT: SL_OBJECT_CLASS = 6;
pub const SL_OBJECT_CLASS_SL_OBJECT_CLASS_LAST: SL_OBJECT_CLASS = 7;
#[doc = "\\brief Lists available object class"]
pub type SL_OBJECT_CLASS = ::std::os::raw::c_uint;
#[doc = "Sets the object detection runtime parameters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_ObjectDetectionRuntimeParameters {
    #[doc = "\\brief Defines the confidence threshold: interval between 1 and 99. A confidence of 1 meaning a low"]
    #[doc = "  threshold, more uncertain objects and 99 very few but very precise objects."]
    #[doc = " If the scene contains a lot of objects, increasing the confidence can slightly speed up the process, since every object instances are tracked."]
    #[doc = ""]
    #[doc = " Default confidence threshold value, used as a fallback when ObjectDetectionRuntimeParameters::object_class_detection_confidence_threshold is partially set"]
    pub detection_confidence_threshold: f32,
    #[doc = "\\brief Select which object types to detect and track. By default all classes are tracked."]
    #[doc = " Fewer object types can slightly speed up the process, since every objects are tracked."]
    #[doc = " Only the selected classes in the vector will be output."]
    #[doc = ""]
    #[doc = "In order to get all the available classes, the filter vector must be empty."]
    pub object_class_filter: [::std::os::raw::c_int; 7usize],
    #[doc = "\\brief Defines a detection threshold for each classes, can be empty for some classes,"]
    #[doc = " ObjectDetectionRuntimeParameters::detection_confidence_threshold will be taken as fallback/default value"]
    pub object_confidence_threshold: [::std::os::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout_SL_ObjectDetectionRuntimeParameters() {
    assert_eq!(
        ::std::mem::size_of::<SL_ObjectDetectionRuntimeParameters>(),
        60usize,
        concat!("Size of: ", stringify!(SL_ObjectDetectionRuntimeParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_ObjectDetectionRuntimeParameters>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SL_ObjectDetectionRuntimeParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionRuntimeParameters>()))
                .detection_confidence_threshold as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionRuntimeParameters),
            "::",
            stringify!(detection_confidence_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionRuntimeParameters>())).object_class_filter
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionRuntimeParameters),
            "::",
            stringify!(object_class_filter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectDetectionRuntimeParameters>()))
                .object_confidence_threshold as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectDetectionRuntimeParameters),
            "::",
            stringify!(object_confidence_threshold)
        )
    );
}
#[doc = "Contains data of a detected object such as its bounding_box, label, id and its 3D position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_ObjectData {
    #[doc = "\\brief Object identification number, used as a reference when tracking the object through the frames"]
    #[doc = "\\note Only available if \\ref ObjectDetectionParameters::enable_tracking is activated else set to -1."]
    pub id: ::std::os::raw::c_int,
    #[doc = "\\brief Unique ID to help identify and track AI detections. Can be either generated externally, or using \\ref sl_generate_unique_id() or left empty"]
    pub unique_object_id: [::std::os::raw::c_uchar; 37usize],
    #[doc = "\\brief Object label, forwarded from \\ref CustomBoxObjects when using \\ref SL_DETECTION_MODEL_CUSTOM_BOX_OBJECTS"]
    pub raw_label: ::std::os::raw::c_int,
    #[doc = "\\brief Object category. Identify the object type (sl::OBJECT_CLASS)"]
    pub label: SL_OBJECT_CLASS,
    #[doc = "\\brief Object subclass (sl::OBJECT_SUBCLASS)"]
    pub sublabel: SL_OBJECT_SUBCLASS,
    #[doc = "\\brief Defines the object tracking state (sl::OBJECT_TRACKING_STATE)."]
    pub tracking_state: SL_OBJECT_TRACKING_STATE,
    #[doc = "\\brief Defines the object action state (sl::OBJECT_ACTION_STATE)."]
    pub action_state: SL_OBJECT_ACTION_STATE,
    #[doc = "\\brief Defines the detection confidence value of the object."]
    #[doc = " From 0 to 100, a low value means the object might not be localized perfectly or the label (OBJECT_CLASS) is uncertain."]
    pub confidence: f32,
    pub mask: *mut ::std::os::raw::c_int,
    pub bounding_box_2d: [SL_Vector2; 4usize],
    #[doc = "\\brief Defines the object 3D centroid."]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    pub position: SL_Vector3,
    #[doc = " \\brief 3D head centroid."]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    #[doc = "\\note Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    pub head_position: SL_Vector3,
    #[doc = "\\brief Defines the object 3D velocity"]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT / seconds, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    pub velocity: SL_Vector3,
    #[doc = " \\brief 3D bounding box of the person represented as eight 3D points"]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    #[doc = ""]
    #[doc = " \\code"]
    #[doc = "1 ------ 2"]
    #[doc = "0 ------ 3 |"]
    #[doc = "| Object | 6"]
    #[doc = "|        |/"]
    #[doc = "4 ------ 7"]
    #[doc = "\\endcode"]
    pub bounding_box: [SL_Vector3; 8usize],
    #[doc = " \\brief bounds the head with eight 3D points."]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    #[doc = "\\note Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    pub head_bounding_box: [SL_Vector3; 8usize],
    #[doc = " \\brief A set of useful points representing the human body, expressed in 2D, respect to the original image resolution."]
    #[doc = " We use a classic 18 points representation, the points semantic and order is given by BODY_PARTS."]
    #[doc = " Expressed in pixels on the original image resolution, [0,0] is the top left corner."]
    #[doc = "\\note Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    #[doc = "\\warning in some cases, eg. body partially out of the image, some keypoint can not be detected, they will have negatives coordinates."]
    pub keypoint_2d: [SL_Vector2; 34usize],
    #[doc = " \\brief A set of useful points representing the human body, expressed in 3D."]
    #[doc = " We use a classic 18 points representation, the points semantic and order is given by BODY_PARTS."]
    #[doc = " Defined in \\ref sl:InitParameters::UNIT, expressed in \\ref RuntimeParameters::measure3D_reference_frame."]
    #[doc = "\\note Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    #[doc = "\\warning in some cases, eg. body partially out of the image or missing depth data, some keypoint can not be detected, they will have non finite values."]
    pub keypoint: [SL_Vector3; 34usize],
    #[doc = "\\brief the covariance matrix of the 3d position, represented by its upper triangular matrix value"]
    #[doc = " \\code"]
    #[doc = "= [p0, p1, p2]"]
    #[doc = "[p1, p3, p4]"]
    #[doc = "[p2, p4, p5]"]
    #[doc = "\\endcode"]
    #[doc = "where pi is position_covariance[i]"]
    pub position_covariance: [f32; 6usize],
    #[doc = " \\brief Per keypoint detection confidence, can not be lower than the \\ref ObjectDetectionRuntimeParameters::detection_confidence_threshold."]
    #[doc = "\\note Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    #[doc = "\\warning in some cases, eg. body partially out of the image or missing depth data, some keypoint can not be detected, they will have non finite values."]
    pub keypoint_confidence: [f32; 34usize],
    #[doc = "\\brief Per keypoint local position (the position of the child keypoint with respect to its parent expressed in its parent coordinate frame)"]
    #[doc = "\\note it is expressed in sl::REFERENCE_CAMERA or sl::REFERENCE_WORLD"]
    #[doc = "Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    pub local_position_per_joint: [SL_Vector3; 34usize],
    #[doc = "\\brief Per keypoint local orientation"]
    #[doc = "\\note the orientation is represented by a quaternion which is stored in sl::float4 (sl::float4 q = sl::float4(qx,qy,qz,qw);)"]
    #[doc = "Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    pub local_orientation_per_joint: [SL_Quaternion; 34usize],
    #[doc = "\\brief global root orientation of the skeleton. The orientation is also represented by a quaternion with the same format as \\ref local_orientation_per_joint"]
    pub global_root_orientation: SL_Quaternion,
}
#[test]
fn bindgen_test_layout_SL_ObjectData() {
    assert_eq!(
        ::std::mem::size_of::<SL_ObjectData>(),
        2152usize,
        concat!("Size of: ", stringify!(SL_ObjectData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_ObjectData>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_ObjectData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).unique_object_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(unique_object_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).raw_label as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(raw_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).label as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).sublabel as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(sublabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).tracking_state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(tracking_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).action_state as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(action_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).confidence as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(confidence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).bounding_box_2d as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(bounding_box_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).position as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).head_position as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(head_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).velocity as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).bounding_box as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(bounding_box)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).head_bounding_box as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(head_bounding_box)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).keypoint_2d as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(keypoint_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectData>())).keypoint as *const _ as usize },
        612usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(keypoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectData>())).position_covariance as *const _ as usize
        },
        1020usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(position_covariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectData>())).keypoint_confidence as *const _ as usize
        },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(keypoint_confidence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectData>())).local_position_per_joint as *const _ as usize
        },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(local_position_per_joint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectData>())).local_orientation_per_joint as *const _
                as usize
        },
        1588usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(local_orientation_per_joint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectData>())).global_root_orientation as *const _ as usize
        },
        2132usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectData),
            "::",
            stringify!(global_root_orientation)
        )
    );
}
#[doc = "\\brief Container to store the externally detected objects. The objects can be ingested"]
#[doc = " using \\ref sl_ingest_custom_box_objects() functions to extract 3D information and tracking over time"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_CustomBoxObjectData {
    #[doc = "\\brief Unique ID to help identify and track AI detections. Can be either generated externally, or using \\ref generate_unique_id() or left empty"]
    pub unique_object_id: [::std::os::raw::c_char; 37usize],
    #[doc = " \\brief 2D bounding box represented as four 2D points starting at the top left corner and rotation clockwise."]
    #[doc = " Expressed in pixels on the original image resolution, [0,0] is the top left corner."]
    #[doc = " \\code"]
    #[doc = "A ------ B"]
    #[doc = "| Object |"]
    #[doc = "D ------ C"]
    #[doc = "\\endcode"]
    pub bounding_box_2d: [SL_Vector2; 4usize],
    #[doc = "\\brief Object label, this information is passed-through and can be used to improve object tracking"]
    pub label: ::std::os::raw::c_int,
    #[doc = "\\brief Detection confidence. Should be [0-1]. It can be used to improve the object tracking"]
    pub probability: f32,
    #[doc = "\\brief Provide hypothesis about the object movements(degrees of freedom) to improve the object tracking"]
    #[doc = " true: means 2 DoF projected alongside the floor plane, the default for object standing on the ground such as person, vehicle, etc"]
    #[doc = " false : 6 DoF full 3D movements are allowed"]
    pub is_grounded: bool,
}
#[test]
fn bindgen_test_layout_SL_CustomBoxObjectData() {
    assert_eq!(
        ::std::mem::size_of::<SL_CustomBoxObjectData>(),
        84usize,
        concat!("Size of: ", stringify!(SL_CustomBoxObjectData))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_CustomBoxObjectData>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_CustomBoxObjectData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CustomBoxObjectData>())).unique_object_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CustomBoxObjectData),
            "::",
            stringify!(unique_object_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CustomBoxObjectData>())).bounding_box_2d as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CustomBoxObjectData),
            "::",
            stringify!(bounding_box_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_CustomBoxObjectData>())).label as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CustomBoxObjectData),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CustomBoxObjectData>())).probability as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CustomBoxObjectData),
            "::",
            stringify!(probability)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_CustomBoxObjectData>())).is_grounded as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_CustomBoxObjectData),
            "::",
            stringify!(is_grounded)
        )
    );
}
#[doc = "Contains the result of the object detection module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Objects {
    #[doc = "\\brief Number of detected objects. Used to iterate through the object_list array."]
    pub nb_object: ::std::os::raw::c_int,
    #[doc = "\\brief Defines the timestamp corresponding to the frame acquisition."]
    #[doc = " This value is especially useful for the async mode to synchronize the data."]
    pub image_ts: ::std::os::raw::c_ulonglong,
    #[doc = "\\brief Defined if the object list has already been retrieved or not."]
    pub is_new: ::std::os::raw::c_int,
    #[doc = "\\brief Defined if both the object tracking and the world orientation has been setup."]
    pub is_tracked: ::std::os::raw::c_int,
    #[doc = "\\brief Detection model used (SL_DETECTION_MODEL)."]
    pub detection_model: SL_DETECTION_MODEL,
    #[doc = "\\brief The list of detected objects"]
    pub object_list: [SL_ObjectData; 75usize],
}
#[test]
fn bindgen_test_layout_SL_Objects() {
    assert_eq!(
        ::std::mem::size_of::<SL_Objects>(),
        161432usize,
        concat!("Size of: ", stringify!(SL_Objects))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Objects>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_Objects))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).nb_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(nb_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).image_ts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(image_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).is_new as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(is_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).is_tracked as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(is_tracked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).detection_model as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(detection_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Objects>())).object_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Objects),
            "::",
            stringify!(object_list)
        )
    );
}
#[doc = " \\brief Objects batch structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_ObjectsBatch {
    pub nb_data: ::std::os::raw::c_int,
    pub id: ::std::os::raw::c_int,
    pub label: SL_OBJECT_CLASS,
    pub sublabel: SL_OBJECT_SUBCLASS,
    pub tracking_state: SL_OBJECT_TRACKING_STATE,
    pub positions: [SL_Vector3; 200usize],
    pub position_covariances: [[f32; 6usize]; 200usize],
    pub velocities: [SL_Vector3; 200usize],
    pub timestamps: [::std::os::raw::c_ulonglong; 200usize],
    pub bounding_boxes_2d: [[SL_Vector2; 4usize]; 200usize],
    pub bounding_boxes: [[SL_Vector3; 8usize]; 200usize],
    pub confidences: [f32; 200usize],
    pub action_states: [SL_OBJECT_ACTION_STATE; 200usize],
    pub keypoints_2d: [[SL_Vector2; 18usize]; 200usize],
    pub keypoints: [[SL_Vector3; 18usize]; 200usize],
    pub head_bounding_boxes_2d: [[SL_Vector2; 4usize]; 200usize],
    pub head_bounding_boxes: [[SL_Vector3; 8usize]; 200usize],
    pub head_positions: [SL_Vector3; 200usize],
    pub keypoints_confidences: [[f32; 18usize]; 200usize],
}
#[test]
fn bindgen_test_layout_SL_ObjectsBatch() {
    assert_eq!(
        ::std::mem::size_of::<SL_ObjectsBatch>(),
        152824usize,
        concat!("Size of: ", stringify!(SL_ObjectsBatch))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_ObjectsBatch>(),
        8usize,
        concat!("Alignment of ", stringify!(SL_ObjectsBatch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).nb_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(nb_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).label as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).sublabel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(sublabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).tracking_state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(tracking_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).positions as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(positions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectsBatch>())).position_covariances as *const _ as usize
        },
        2420usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(position_covariances)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).velocities as *const _ as usize },
        7220usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(velocities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).timestamps as *const _ as usize },
        9624usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(timestamps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectsBatch>())).bounding_boxes_2d as *const _ as usize
        },
        11224usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(bounding_boxes_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).bounding_boxes as *const _ as usize },
        17624usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(bounding_boxes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).confidences as *const _ as usize },
        36824usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(confidences)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).action_states as *const _ as usize },
        37624usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(action_states)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).keypoints_2d as *const _ as usize },
        38424usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(keypoints_2d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).keypoints as *const _ as usize },
        67224usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(keypoints)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectsBatch>())).head_bounding_boxes_2d as *const _ as usize
        },
        110424usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(head_bounding_boxes_2d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectsBatch>())).head_bounding_boxes as *const _ as usize
        },
        116824usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(head_bounding_boxes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_ObjectsBatch>())).head_positions as *const _ as usize },
        136024usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(head_positions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SL_ObjectsBatch>())).keypoints_confidences as *const _ as usize
        },
        138424usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_ObjectsBatch),
            "::",
            stringify!(keypoints_confidences)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SL_Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SL_Rect() {
    assert_eq!(
        ::std::mem::size_of::<SL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SL_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<SL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SL_Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Rect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Rect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SL_Rect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SL_Rect),
            "::",
            stringify!(height)
        )
    );
}
extern "C" {
    #[doc = "\\brief Forces unload of all instances."]
    pub fn sl_unload_all_instances();
}
extern "C" {
    #[doc = "\\brief Forces unload of one instance."]
    #[doc = "\\param camera_id : id of the instance to unload."]
    pub fn sl_unload_instance(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Checks usb devices connected."]
    #[doc = "param device : type of device to find."]
    #[doc = "\\return true if connected."]
    pub fn sl_find_usb_device(device: USB_DEVICE) -> bool;
}
extern "C" {
    #[doc = " \\brief Creates a camera with resolution mode, fps and id for linux."]
    #[doc = " \\param camera_id : id of the camera to be added."]
    #[doc = " \\param verbose : Enable verbose mode."]
    #[doc = " \\return true if the camera has been created successfully."]
    pub fn sl_create_camera(camera_id: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief Reports if the camera has been successfully opened."]
    #[doc = "\\param camera_id : id of the camera."]
    #[doc = "\\return true if the ZED is already setup, otherwise false."]
    pub fn sl_is_opened(camera_id: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief Opens the camera depending on the init parameters."]
    #[doc = "\\param camera_id : id of the camera."]
    #[doc = "\\param init_parameters : structure containing all the initial parameters."]
    #[doc = "\\param path_svo : filename of the svo (for SVO input)."]
    #[doc = "\\param ip : ip of the camera to open (for Stream input)."]
    #[doc = "\\param stream_port : port of the camera to open (for Stream input)."]
    #[doc = "\\param output_file : sdk verbose log file. Redirect the SDK verbose message to file."]
    #[doc = "\\param opt_settings_path : optional settings path. Equivalent to  \\ref InitParameters::optional_settings_path."]
    #[doc = "\\param opencv_calib_path : optional openCV calibration file. Equivalent to  \\ref InitParameters::optional_opencv_calibration_file."]
    #[doc = "\\return An error code giving information about the internal process. If SUCCESS (0) is returned, the camera is ready to use. Every other code indicates an error and the program should be stopped."]
    pub fn sl_open_camera(
        camera_id: ::std::os::raw::c_int,
        init_parameters: *mut SL_InitParameters,
        path_svo: *const ::std::os::raw::c_char,
        ip: *const ::std::os::raw::c_char,
        stream_port: ::std::os::raw::c_int,
        output_file: *const ::std::os::raw::c_char,
        opt_settings_path: *const ::std::os::raw::c_char,
        opencv_calib_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the initparameters used to open the ZED camera"]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_get_init_parameters(camera_id: ::std::os::raw::c_int) -> *mut SL_InitParameters;
}
extern "C" {
    #[doc = "\\brief Returns the Runtimeparameters used to open the ZED camera"]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return a structure containing all the runtime parameters."]
    pub fn sl_get_runtime_parameters(camera_id: ::std::os::raw::c_int)
        -> *mut SL_RuntimeParameters;
}
extern "C" {
    #[doc = "\\brief Returns the PositionalTrackingParameters"]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return a structure containing all the positional tracking parameters"]
    pub fn sl_get_positional_tracking_parameters(
        camera_id: ::std::os::raw::c_int,
    ) -> *mut SL_PositionalTrackingParameters;
}
extern "C" {
    #[doc = "\\brief Destroys the camera and disable the textures."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_close_camera(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Grabs the lastest images from the camera."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param runtime : structure containing all the runtime parameters."]
    #[doc = "\\return An error code giving information about the internal process.\"SUCCESS\" if the method succeeded."]
    pub fn sl_grab(
        camera_id: ::std::os::raw::c_int,
        runtime: *mut SL_RuntimeParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Lists all the connected devices with their associated information."]
    #[doc = ""]
    #[doc = "This function lists all the cameras available and provides their serial number, models and other information."]
    #[doc = "\\param device_list [Out] : the devices properties for each connect camera."]
    #[doc = "\\param nb_devices : the number of cameras connected."]
    pub fn sl_get_device_list(
        device_list: *mut SL_DeviceProperties,
        nb_devices: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Performs an hardware reset of the ZED 2 / ZED 2i."]
    #[doc = "\\param sn : serial number of the camera to reset, or 0 to reset the first camera detected."]
    #[doc = "\\param fullReboot : Perform a full reboot (Sensors and Video modules)"]
    pub fn sl_reboot(sn: ::std::os::raw::c_int, full_reboot: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Creates a file for recording the ZED's output into a .SVO or .AVI video. An SVO is Stereolabs' own format designed for the ZED. It holds the video feed with timestamps as well as info about the camera used to record it."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param filename : filename of the SVO file."]
    #[doc = "\\param compression_mode : compression mode. Can be one for the \\ref SL_SVO_COMPRESSION_MODE enum."]
    #[doc = "\\param bitrate : overrides default bitrate of the SVO file, in KBits/s. Only works if \\ref SVO_COMPRESSION_MODE is H264 or H265."]
    #[doc = "\\param target_fps : defines the target framerate for the recording module."]
    #[doc = "\\param transcode : in case of streaming input, if set to false, it will avoid decoding/re-encoding and convert directly streaming input to a SVO file."]
    #[doc = "This saves a encoding session and can be especially useful on NVIDIA Geforce cards where the number of encoding session is limited."]
    #[doc = "\\return An ERROR_CODE that defines if SVO file was successfully created and can be filled with images."]
    pub fn sl_enable_recording(
        camera_id: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        compression_mode: SL_SVO_COMPRESSION_MODE,
        bitrate: ::std::os::raw::c_uint,
        target_fps: ::std::os::raw::c_int,
        transcode: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Disables the recording initiated by enableRecording() and closes the generated file."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_disable_recording(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Pauses or resumes the recording."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param status : if true, the recording is paused. If false, the recording is resumed."]
    pub fn sl_pause_recording(camera_id: ::std::os::raw::c_int, status: bool);
}
extern "C" {
    #[doc = "\\brief Initializes and starts the positional tracking processes."]
    #[doc = "This function allows you to enable the position estimation of the SDK. It only has to be called once in the camera's lifetime."]
    #[doc = ""]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param area_file_path : area localization file that describes the surroundings, saved from a previous tracking session."]
    #[doc = "\\return \\ref SL_ERROR_CODE::SUCCESS if everything went fine, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_enable_positional_tracking(
        camera_id: ::std::os::raw::c_int,
        tracking_param: *mut SL_PositionalTrackingParameters,
        area_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Initializes and starts the positional tracking processes."]
    #[doc = "This function allows you to enable the position estimation of the SDK. It only has to be called once in the camera's lifetime."]
    #[doc = ""]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param initial_world_rotation : rotation of the camera in the world frame when the camera is started. By default, it should be identity."]
    #[doc = "\\param initial_world_position : position of the camera in the world frame when the camera is started. By default, it should be identity."]
    #[doc = "\\param enable_area_memory : this mode enables the camera to remember its surroundings. This helps correct positional tracking drift, and can be helpful for positioning different cameras relative to one other in space."]
    #[doc = "\\param enable_pose_smoothing : this mode enables smooth pose correction for small drift correction."]
    #[doc = "\\param set_floor_as_origin : this mode initializes the tracking to be aligned with the floor plane to better position the camera in space."]
    #[doc = "\\param set_as_static : this mode defines the camera as static. If true, it will not move in the environment. This allows you to set its position using initial_world_transform."]
    #[doc = "\\param enable_imu_fusion : this mode enables or disables IMU fusion. When set to false, only the optical odometry will be used."]
    #[doc = "\\param area_file_path : area localization file that describes the surroundings, saved from a previous tracking session."]
    #[doc = "\\return \\ref SL_ERROR_CODE::SUCCESS if everything went fine, ERROR_CODE::FAILURE otherwise."]
    #[doc = "bool enable_imu_fusion, const char* area_file_path);*/"]
    #[doc = "\\brief Disables the positional tracking."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param area_file_path : if set, saves the spatial memory into an '.area' file."]
    pub fn sl_disable_positional_tracking(
        camera_id: ::std::os::raw::c_int,
        area_file_path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "\\brief Saves the current area learning file. The file will contain spatial memory data generated by the tracking."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param area_file_path : save the spatial memory database in an '.area' file."]
    #[doc = "\\return \\ref SL_ERROR_CODE::FAILURE if the area_file_path file wasn't found, SUCCESS otherwise."]
    pub fn sl_save_area_map(
        camera_id: ::std::os::raw::c_int,
        area_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the state of the spatial memory export process."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current state (SL_AREA_EXPORTING_STATE) of the spatial memory export process"]
    pub fn sl_get_area_export_state(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the depth max value (see \\ref SL_InitParameters::depth_maximum_distance)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The max depth value."]
    pub fn sl_get_depth_max_range_value(camera_id: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = "\\brief  Sets the playback cursor to the desired frame number in the SVO file."]
    #[doc = "This function allows you to move around within a played-back SVO file. After calling, the next call to grab() will read the provided frame number."]
    #[doc = ""]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param frame_number : the number of the desired frame to be decoded."]
    pub fn sl_set_svo_position(
        camera_id: ::std::os::raw::c_int,
        frame_number: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Returns the camera FPS."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current frame rate."]
    pub fn sl_get_camera_fps(camera_id: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = "\\brief Returns the current FPS."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current frame rate."]
    pub fn sl_get_current_fps(camera_id: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = "\\brief Returns the width of the current image."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return Width of the image."]
    pub fn sl_get_width(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the height of the current image."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return Height of the image."]
    pub fn sl_get_height(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the current confidence threshold value for the disparity map (and by extension the depth map)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The confidence threshold."]
    pub fn sl_get_confidence_threshold(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Performs a new self calibration process."]
    #[doc = "In some cases, due to temperature changes or strong vibrations, the stereo calibration becomes less accurate. Use this function to update the self-calibration data and get more reliable depth values."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_update_self_calibration(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Gets the Calibration Parameters."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param raw_params : if true, returns Intrinsic and Extrinsic stereo parameters for original images (unrectified/distorded), else returns parameters for rectified/undistorded images."]
    #[doc = "\\return Structure containing Intrinsic and Extrinsic stereo parameters"]
    pub fn sl_get_calibration_parameters(
        camera_id: ::std::os::raw::c_int,
        raw_params: bool,
    ) -> *mut SL_CalibrationParameters;
}
extern "C" {
    #[doc = "\\brief Gets the Sensors configuration."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return Structure containing information about all the sensors available in the current device."]
    pub fn sl_get_sensors_configuration(
        camera_id: ::std::os::raw::c_int,
    ) -> *mut SL_SensorsConfiguration;
}
extern "C" {
    #[doc = "\\brief Gets the IMU to Left camera transform matrix."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param translation : translation between IMU frame and camera frame."]
    #[doc = "\\param rotation : rotation between IMU frame and camera frame."]
    pub fn sl_get_camera_imu_transform(
        camera_id: ::std::os::raw::c_int,
        translation: *mut SL_Vector3,
        rotation: *mut SL_Quaternion,
    );
}
extern "C" {
    #[doc = "\\brief Gets the input type (see \\ref SL_INPUT_TYPE)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The input type."]
    pub fn sl_get_input_type(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the ZED Serial Number."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The serial number of the camera."]
    pub fn sl_get_zed_serial(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the ZED camera Current Firmware version."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The firmware of the camera."]
    pub fn sl_get_camera_firmware(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the ZED mcu Current Firmware version."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The firmware version of the sensor module, 0 if no sensors are available."]
    pub fn sl_get_sensors_firmware(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the ZED Camera model (see \\ref SL_MODEL)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The ZED Camera model."]
    pub fn sl_get_camera_model(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Get the Timestamp at the time the frame has been extracted from USB stream. (should be called after a grab)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The Camera timestamp."]
    pub fn sl_get_image_timestamp(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = "\\brief Get the current Timestamp at the time the function is called. Can be compared to the camera Timestamp for synchronization."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current timestamp."]
    pub fn sl_get_current_timestamp(
        camera_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[doc = "\\brief Gets the total number of frames in the loaded SVO file."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The total number of frames in the SVO file (-1 if the SDK is not reading a SVO)."]
    pub fn sl_get_svo_number_of_frames(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value in the ZED's camera settings."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param mode : Setting to be changed"]
    #[doc = "\\param value : new value"]
    pub fn sl_set_camera_settings(
        camera_id: ::std::os::raw::c_int,
        mode: SL_VIDEO_SETTINGS,
        value: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Sets the region of interest for automatic exposure/gain computation"]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param side : defines left,right,both to distinguish between left and right or both sides (see \\ref SL_SIDE)."]
    #[doc = "\\param roi : Region of interest."]
    #[doc = "\\param reset : reset aestruct C_agc if true."]
    #[doc = "\\return SL_ERROR_CODE::SUCCESS if ROI has been applied. Other ERROR_CODE otherwise."]
    pub fn sl_set_roi_for_aec_agc(
        camera_id: ::std::os::raw::c_int,
        side: SL_SIDE,
        roi: *mut SL_Rect,
        reset: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the value of a given setting from the ZED camera."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param mode : Setting to be retrieved (see \\ref SL_VIDEO_SETTINGS)."]
    #[doc = "\\return The current value for the corresponding setting. Returns -1 if encounters an error."]
    pub fn sl_get_camera_settings(
        camera_id: ::std::os::raw::c_int,
        mode: SL_VIDEO_SETTINGS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the region of interest for automatic exposure/gain computation"]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param side : defines left,right,both to distinguish between left and right or both sides (see \\ref SL_SIDE)."]
    #[doc = "\\param roi [Out] : Region of interest."]
    #[doc = "\\return SL_ERROR_CODE::SUCCESS if ROI has been applied. Other ERROR_CODE otherwise."]
    pub fn sl_get_roi_for_aec_agc(
        id: ::std::os::raw::c_int,
        side: SL_SIDE,
        roi: *mut SL_Rect,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the closest measurable distance by the camera, according to the camera type and depth map parameters. Equivalent of SL_InitParameters::depth_minimum_distance)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The minimum depth distance."]
    pub fn sl_get_depth_min_range_value(camera_id: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    #[doc = "\\brief Gets the number of zed connected."]
    #[doc = "\\return The number of Zed cameras connected."]
    pub fn sl_get_number_zed_connected() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the version of the currently installed ZED SDK."]
    #[doc = "\\return The ZED SDK version installed."]
    pub fn sl_get_sdk_version() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Gets the current position of the SVO being recorded to."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current SVO position;"]
    pub fn sl_get_svo_position(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the number of frames dropped since Grab() was called for the first time. Based on camera timestamps and an FPS comparison."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The number of frames dropped since the first Grab() call."]
    pub fn sl_get_frame_dropped_count(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = "\\brief Gets the current position of the camera and state of the tracking, with an optional offset to the tracking frame."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return true if the tracking module is enabled"]
    pub fn sl_is_positional_tracking_enabled(camera_id: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief Gets the current position of the camera and state of the tracking, with an optional offset to the tracking frame."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param rotation : Quaternion filled with the current rotation of the camera depending on its reference frame."]
    #[doc = "\\param position : Vector filled with the current position of the camera depending on its reference frame."]
    #[doc = "\\param target_quaternion : Rotational offset applied to the tracking frame."]
    #[doc = "\\param target_translation : Positional offset applied to the tracking frame."]
    #[doc = "\\param reference_frame : Reference frame for setting the rotation/position."]
    #[doc = "\\return The current state of the tracking process (see \\ref SL_POSITIONAL_TRACKING_STATE)."]
    pub fn sl_get_position_at_target_frame(
        camera_id: ::std::os::raw::c_int,
        rotation: *mut SL_Quaternion,
        position: *mut SL_Vector3,
        target_quaternion: *mut SL_Quaternion,
        target_translation: *mut SL_Vector3,
        reference_frame: SL_REFERENCE_FRAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the current position of the camera and state of the tracking, filling a PoseData struck useful for AR pass-though."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param poseData : Current Pose."]
    #[doc = "\\param reference_frame : Reference frame sor setting the rotation/position."]
    #[doc = "\\return The current state of the tracking process (see \\ref SL_POSITIONAL_TRACKING_STATE)."]
    pub fn sl_get_position_data(
        camera_id: ::std::os::raw::c_int,
        poseData: *mut SL_PoseData,
        reference_frame: SL_REFERENCE_FRAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves the estimated position and orientation of the camera in the specified \\ref REFERENCE_FRAME \"reference frame\"."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param rotation : Quaternion filled with the current rotation of the camera depending on its reference frame."]
    #[doc = "\\param position : Vector filled with the current position of the camera depending on its reference frame."]
    #[doc = "\\param reference_frame : Reference frame for setting the rotation/position."]
    #[doc = "\\return The current state of the tracking process (see \\ref SL_POSITIONAL_TRACKING_STATE)."]
    pub fn sl_get_position(
        camera_id: ::std::os::raw::c_int,
        rotation: *mut SL_Quaternion,
        position: *mut SL_Vector3,
        reference_frame: SL_REFERENCE_FRAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the position of the camera and the current state of the ZED Tracking as a float array (4x4)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param pose : pose of the camera as a float array (float[16])."]
    #[doc = "\\param reference_frame : the reference from which you want the pose to be expressed (see SL_REFERENCE_FRAME::WORLD)."]
    #[doc = "\\return The Positional tracking state."]
    pub fn sl_get_position_array(
        camera_id: ::std::os::raw::c_int,
        pose: *mut f32,
        reference_frame: SL_REFERENCE_FRAME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Resets the tracking, and re-initializes the position with the given pose"]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param rotation : rotation of the camera in the world frame when the function is called."]
    #[doc = "\\param translation : position of the camera in the world frame when the function is called."]
    #[doc = "\\return SL_ERROR_CODE::SUCCESS if the tracking has been reset, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_reset_positional_tracking(
        camera_id: ::std::os::raw::c_int,
        rotation: SL_Quaternion,
        translation: SL_Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Resets the tracking with an offset."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param rotation : rotation of the camera in the world frame when the function is called."]
    #[doc = "\\param translation : position of the camera in the world frame when the function is called."]
    #[doc = "\\param target_quaternion : rotation offset to apply."]
    #[doc = "\\param target_translation : translation offset to apply."]
    #[doc = "\\return SL_ERROR_CODE::SUCCESS if the tracking has been reset, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_reset_positional_tracking_with_offset(
        camera_id: ::std::os::raw::c_int,
        rotation: SL_Quaternion,
        translation: SL_Vector3,
        target_quaternion: SL_Quaternion,
        target_translation: SL_Vector3,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a prior to the IMU orientation (using a ZED-mini, ZED2 or ZED2i)."]
    #[doc = "Prior must come from a external IMU, such as the HMD orientation and should be in a time frame"]
    #[doc = "that's as close as possible to the camera."]
    #[doc = "\\param rotation : Prior rotation."]
    #[doc = "\\SUCCESS if the transform has been passed, ERROR_CODE::INVALID_FUNCTION_CALL otherwise"]
    pub fn sl_set_imu_prior_orientation(
        camera_id: ::std::os::raw::c_int,
        rotation: SL_Quaternion,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the rotation given by the ZED-M/ZED2 IMU. Returns an error if using ZED (v1) which does not contains internal sensors."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param quat [Out]: Rotation from the IMU."]
    #[doc = "\\param time_reference : time reference."]
    #[doc = "\\return ERROR_CODE::SUCCESS if sensors data have been extracted."]
    pub fn sl_get_imu_orientation(
        camera_id: ::std::os::raw::c_int,
        quat: *mut SL_Quaternion,
        time_reference: SL_TIME_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the full Sensor data from the ZED-M/ZED2/ZED2i. Returns an error is using ZED (v1) which does not contains internal sensors."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param data : sensor data."]
    #[doc = "\\param time_reference : time reference."]
    #[doc = "\\return ERROR_CODE::SUCCESS if sensors data have been extracted."]
    pub fn sl_get_sensors_data(
        camera_id: ::std::os::raw::c_int,
        data: *mut SL_SensorData,
        time_reference: SL_TIME_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Consolidates the chucks from a scan. This is used to turn a lots of small meshes (which are efficient for the scanning process)"]
    #[doc = "into several large meshes (which are more convenient to work with)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param nb_faces : define the new number of faces per chunk (useful for Unity that doesn't handle chunks over 65K vertices)."]
    #[doc = "\\param nb_vertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_updated_submeshes : Number of submeshes."]
    #[doc = "\\param updates_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param nb_vertices_tot : Total number of updated vertices in all submeshes."]
    #[doc = "\\param nb_triangles_tot : Total number of updated triangles in all submeshes."]
    #[doc = "\\param max_sub_mesh : Maximum number of submeshes."]
    pub fn sl_spatial_mapping_merge_chunks(
        camera_id: ::std::os::raw::c_int,
        nb_faces: ::std::os::raw::c_int,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        nb_updated_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "\\brief Initializes and begins the spatial mapping processes."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param type : Spatial mapping type (see \\ref SL_SPATIAL_MAP_TYPE)."]
    #[doc = "\\param resolution_meter : Spatial mapping resolution in meters."]
    #[doc = "\\param max_range_meter : Maximum scanning range in meters."]
    #[doc = "\\param save_texture : True to scan surface textures in addition to geometry."]
    #[doc = "\\param max_memory_usage : The maximum CPU memory (in megabytes) allocated for the meshing process."]
    #[doc = "\\return SUCCESS if everything went fine, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_enable_spatial_mapping(
        camera_id: ::std::os::raw::c_int,
        mapping_param: *mut SL_SpatialMappingParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Disables the Spatial Mapping process."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_disable_spatial_mapping(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "Sets the pause state of the data integration mechanism for the ZED's spatial mapping."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param status : If true, the integration is paused. If false, the spatial mapping is resumed."]
    pub fn sl_pause_spatial_mapping(camera_id: ::std::os::raw::c_int, status: bool);
}
extern "C" {
    #[doc = "\\brief Starts the mesh generation process in a thread that doesn't block the spatial mapping process."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_request_mesh_async(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Returns the mesh generation status. Useful for knowing when to update and retrieve the mesh."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return SUCCESS if the mesh is ready and not yet retrieved, otherwise ERROR_CODE::FAILURE."]
    pub fn sl_get_mesh_request_status_async(
        camera_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the current state of spatial mapping."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return The current state ( \\ref SL_SPATIAL_MAPPING_STATE) of the spatial mapping process ("]
    pub fn sl_get_spatial_mapping_state(
        camera_id: ::std::os::raw::c_int,
    ) -> SL_SPATIAL_MAPPING_STATE;
}
extern "C" {
    #[doc = "\\brief Updates the internal version of the mesh and returns the sizes of the meshes."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param nb_vertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_submeshes : Number of submeshes."]
    #[doc = "\\param updates_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param num_vertices_tot : Total number of updated vertices in all submeshes."]
    #[doc = "\\param num_triangles_tot : Total number of updated triangles in all submeshes."]
    #[doc = "\\param max_sub_mesh : Maximum number of submeshes."]
    #[doc = "\\return SUCCESS if the mesh is updated."]
    pub fn sl_update_mesh(
        camera_id: ::std::os::raw::c_int,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        nb_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves all chunks of the generated mesh. Call update_mesh before calling this."]
    #[doc = "Vertex and triangles arrays must be at least of the sizes returned by update_mesh (nb_vertices and nb_triangles)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param vertices : Vertices of the mesh"]
    #[doc = "\\param triangles : Triangles of the mesh."]
    #[doc = "\\param max_submeshes : Maximum number of submesh that can be handled."]
    #[doc = "\\param uvs : uvs of the texture."]
    #[doc = "\\param texture_ptr : Texture of the mesh (if enabled)."]
    #[doc = "\\return SUCCESS if the mesh is retrieved."]
    pub fn sl_retrieve_mesh(
        camera_id: ::std::os::raw::c_int,
        vertices: *mut f32,
        triangles: *mut ::std::os::raw::c_int,
        uvs: *mut f32,
        texture_ptr: *mut ::std::os::raw::c_uchar,
        max_submeshes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Updates the internal version of the mesh and returns the sizes of the meshes."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param nb_vertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_submeshes : Number of submeshes."]
    #[doc = "\\param updates_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param num_vertices_tot : Total number of updated vertices in all submeshes."]
    #[doc = "\\param num_triangles_tot : Total number of updated triangles in all submeshes."]
    #[doc = "\\param max_sub_mesh : Maximum number of submeshes."]
    #[doc = "\\return SUCCESS if the chunks are updated."]
    pub fn sl_update_chunks(
        camera_id: ::std::os::raw::c_int,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        nb_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves one chunk data. Call update_chunks before calling this."]
    #[doc = "Vertex and triangles arrays must be at least of the sizes returned by update_mesh (nbVertices and nbTriangles)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param max_submesh : Maximum number of submesh that can be handled."]
    #[doc = "\\param vertices : Vertices of the chunk"]
    #[doc = "\\param triangles : Triangles of the chunk."]
    #[doc = "\\return SUCCESS if the chunk is retrieved."]
    pub fn sl_retrieve_chunks(
        camera_id: ::std::os::raw::c_int,
        vertices: *mut f32,
        triangles: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Updates the fused point cloud (if spatial map type was FUSED_POINT_CLOUD)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param num_vertices_tot : returns the total number of vertices."]
    #[doc = "\\return SUCCESS if the fused point cloud is updated."]
    pub fn sl_update_fused_point_cloud(
        camera_id: ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves all points of the fused point cloud. Call update_fused_point_cloud before calling this."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param vertices : Points of the fused point cloud."]
    #[doc = "\\return SUCCESS if the fused point cloud is retrieved."]
    pub fn sl_retrieve_fused_point_cloud(
        camera_id: ::std::os::raw::c_int,
        vertices: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Extracts the current spatial map from the spatial mapping process."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "SUCCESS if the mesh is filled and available, otherwise FAILURE."]
    pub fn sl_extract_whole_spatial_map(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Saves the scanned mesh in a specific file format."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param filename : Path and filename of the mesh."]
    #[doc = "\\param format : File format (extension). Can be .obj, .ply or .bin."]
    #[doc = "\\return True if the file was successfully saved, false otherwise."]
    pub fn sl_save_mesh(
        camera_id: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        format: SL_MESH_FILE_FORMAT,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Saves the scanned point cloud in a specific file format."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param filename : Path and filename of the point cloud."]
    #[doc = "\\param format : File format (extension). Can be .obj, .ply or .bin."]
    #[doc = "\\return True if the file was successfully saved, false otherwise."]
    pub fn sl_save_point_cloud(
        c_id: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        format: SL_MESH_FILE_FORMAT,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Loads a saved mesh file."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param filename : Path and filename of the mesh. Should incluse the extension (.obj, .ply or .bin)."]
    #[doc = "\\param nb_ertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_sub_meshes : Number of submeshes."]
    #[doc = "\\param updated_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param nb_vertices_tot :  Total number of updated vertices in all submeshes."]
    #[doc = "\\param nb_triangles_tot : Array of the number of triangles in each submesh."]
    #[doc = "\\param max_submesh : Maximum number of submeshes taht can be handled."]
    #[doc = "\\param texture_size : Array containing the sizes of all the textures (width ,height) if applicable."]
    #[doc = "\\return True if the file was successfully loaded, false otherwise."]
    pub fn sl_load_mesh(
        camera_id: ::std::os::raw::c_int,
        filename: *const ::std::os::raw::c_char,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        num_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        textures_size: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Applies the scanned texture onto the internal scanned mesh."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param nb_vertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_sub_meshes : Number of submeshes."]
    #[doc = "\\param updated_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param nb_vertices_tot :  Total number of updated vertices in all submeshes."]
    #[doc = "\\param nb_triangles_tot : Array of the number of triangles in each submesh."]
    #[doc = "\\param max_submesh : Maximum number of submeshes taht can be handled."]
    #[doc = "\\param texture_size : Array containing the sizes of all the textures (width ,height) if applicable."]
    #[doc = "\\return True if the texturing was successful, false otherwise."]
    pub fn sl_apply_texture(
        camera_id: ::std::os::raw::c_int,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        nb_updated_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        textures_size: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Filters a mesh to removes triangles while still preserving its overall shaper (though less accurate)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param filter_params : Filter level. Higher settings remore more triangles (SL_MeshFilterParameters::MESH_FILTER)."]
    #[doc = "\\param nb_ vertices : Array of the number of vertices in each submesh."]
    #[doc = "\\param nb_triangles : Array of the number of triangles in each submesh."]
    #[doc = "\\param nb_sub_meshes : Number of submeshes."]
    #[doc = "\\param updated_indices : List of all submeshes updated since the last update."]
    #[doc = "\\param nb_vertices_tot :  Total number of updated vertices in all submeshes."]
    #[doc = "\\param nb_triangles_tot : Array of the number of triangles in each submesh."]
    #[doc = "\\param max_submesh : Maximum number of submeshes that can be handled."]
    #[doc = "\\return True if the filtering was successful, false otherwise."]
    pub fn sl_filter_mesh(
        camera_id: ::std::os::raw::c_int,
        filter_params: SL_MESH_FILTER,
        nb_vertices: *mut ::std::os::raw::c_int,
        nb_triangles: *mut ::std::os::raw::c_int,
        nb_updated_submeshes: *mut ::std::os::raw::c_int,
        updated_indices: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
        max_submesh: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = "\\brief Gets a vector pointing toward the direction of gravity. This is estimated from a 3D scan of the environment,"]
    #[doc = "and such, a scan must be started and finished for this value to be calculated."]
    #[doc = "If using the ZED_M  /ZED2, this isn't required thanks to its IMU."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param gravity [Out] : vector of gravity."]
    pub fn sl_spatial_mapping_get_gravity_estimation(
        camera_id: ::std::os::raw::c_int,
        gravity: *mut SL_Vector3,
    );
}
extern "C" {
    #[doc = "\\brief Looks for a plane in the visible area that is likely to represent the floor."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param reset_quaternion : The rotation to align the axis with the gravity."]
    #[doc = "\\param reset_translation : The translation to align the tracking with the floor plane. The initial position will then be at ground height."]
    #[doc = "\\param prior_rotation : Prior rotation."]
    #[doc = "\\param prior_translation : Prior translation."]
    #[doc = "\\return The detected floor plane if the function succeeded."]
    pub fn sl_find_floor_plane(
        camera_id: ::std::os::raw::c_int,
        reset_quaternion: *mut SL_Quaternion,
        reset_translation: *mut SL_Vector3,
        prior_rotation: SL_Quaternion,
        prior_translation: SL_Vector3,
    ) -> *mut SL_PlaneData;
}
extern "C" {
    #[doc = "\\brief Check for a plane in hte real world at given screen-space coordinates."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param pixel : Point on the ZED image to check for a plane."]
    #[doc = "\\param thres : Check if area is enough for Unity. If true, removes smaller planes."]
    #[doc = "\\return Data of the detected plane."]
    pub fn sl_find_plane_at_hit(
        camera_id: ::std::os::raw::c_int,
        pixel: SL_Vector2,
        thres: bool,
    ) -> *mut SL_PlaneData;
}
extern "C" {
    #[doc = "\\brief Using data from a detected floor plane, updates supplied vertex and triangles arrays with data needed to make a mesh that represents it."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param vertices : Array to be filled with mesh vertices."]
    #[doc = "\\param triangles : Array to be filled with mesh triangles, stored as indexes of each triangle's points."]
    #[doc = "\\param nb_vertices_tot : Total number of vertices in the mesh."]
    #[doc = "\\param nb_triangles_tot : Total triangles indexes (3x number of triangles)."]
    #[doc = "\\return SUCCESS if the mesh conversion was successful."]
    pub fn sl_convert_floorplane_to_mesh(
        camera_id: ::std::os::raw::c_int,
        vertices: *mut f32,
        triangles: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Using data from a detected hit plane, updates supplied vertex and triangles arrays with data needed to make a mesh that represents it."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param vertices : Array to be filled with mesh vertices."]
    #[doc = "\\param triangles : Array to be filled with mesh triangles, stored as indexes of each triangle's points."]
    #[doc = "\\param nb_vertices_tot : Total number of vertices in the mesh."]
    #[doc = "\\param nb_triangles_tot : Total triangles indexes (3x number of triangles)."]
    #[doc = "\\return SUCCESS if the mesh conversion was successful."]
    pub fn sl_convert_hitplane_to_mesh(
        camera_id: ::std::os::raw::c_int,
        vertices: *mut f32,
        triangles: *mut ::std::os::raw::c_int,
        nb_vertices_tot: *mut ::std::os::raw::c_int,
        nb_triangles_tot: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves a measure texture from the ZED SDK. Use this to get an individual texture from the last grabbed frame with measurements in every pixel -"]
    #[doc = "such as depth map, confidence map etc."]
    #[doc = "Measure textures are not human-viewable but don't lose accuracy, unlike image textures."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param measure_ptr : pointer to the measure texture."]
    #[doc = "\\param type : Measure type (depth, confidence, xyz, etc). See \\ref SL_MEASURE."]
    #[doc = "\\param  mem : Whether the measure should be on CPU or GPU memory. See \\ref SL_MEM."]
    #[doc = "\\param width : width of the texture in pixel."]
    #[doc = "\\param height : height of the texture in pixel."]
    #[doc = "\\return \"SUCCESS\" if the retrieve succeeded."]
    pub fn sl_retrieve_measure(
        camera_id: ::std::os::raw::c_int,
        measure_ptr: *mut ::std::os::raw::c_int,
        type_: SL_MEASURE,
        mem: SL_MEM,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieves an image texture from the ZED SDK in a human-viewable format. Image textures work for when you want the result to be visible,"]
    #[doc = "such as the direct RGB image from the camera, or a greyscale image of the depth. However it will lose accuracy if used to show measurements"]
    #[doc = "like depth or confidence, unlike measure textures."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param image_ptr : pointer to the image texture."]
    #[doc = "\\param type : Image type (left RGB, right depth map, etc). See \\ref SL_VIEW."]
    #[doc = "\\param  mem : Whether the image should be on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\param width : width of the texture in pixel."]
    #[doc = "\\param height : height of the texture in pixel."]
    #[doc = "\\return \"SUCCESS\" if the retrieve succeeded."]
    pub fn sl_retrieve_image(
        camera_id: ::std::os::raw::c_int,
        image_ptr: *mut ::std::os::raw::c_int,
        type_: SL_VIEW,
        mem: SL_MEM,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Creates a streaming pipeline."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param codec : defines the codec used for streaming (see \\ref SL_STREAMING_CODE)."]
    #[doc = "\\param bitrate : defines the streaming bitrate in Kbits/s."]
    #[doc = "| STREAMING_CODEC  | Resolution   | FPS   | bitrate (kbps) |"]
    #[doc = "|------------------|--------------|-------|----------------|"]
    #[doc = "| H264             |  HD2K        |   15  |     8500       |"]
    #[doc = "| H264             |  HD1080      |   30  |    12500       |"]
    #[doc = "| H264             |  HD720       |   60  |     7000       |"]
    #[doc = "| H265             |  HD2K        |   15  |     7000       |"]
    #[doc = "| H265             |  HD1080      |   30  |    11000       |"]
    #[doc = "| H265             |  HD720       |   60  |     6000       |"]
    #[doc = ""]
    #[doc = "\\note Available range : [1000 - 60000]"]
    #[doc = "\\param port : defines the port used for streaming."]
    #[doc = "\\param gop_size : defines the gop size in number of frames."]
    #[doc = "\\param adaptative_bitrate : enable/disable adaptive bitrate."]
    #[doc = "\\param chunk_size : defines a single chunk size."]
    #[doc = "\\param target_framrate : defines the target framerate for the streaming output."]
    #[doc = "\\return An ERROR_CODE that defines if the stream was started."]
    pub fn sl_enable_streaming(
        camera_id: ::std::os::raw::c_int,
        codec: SL_STREAMING_CODEC,
        bitrate: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_ushort,
        gop_size: ::std::os::raw::c_int,
        adaptative_bitrate: ::std::os::raw::c_int,
        chunk_size: ::std::os::raw::c_int,
        target_framerate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Tells if the streaming is running (true) or still initializing (false)."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\return True is the streaming is running, False if still initializing."]
    pub fn sl_is_streaming_enabled(camera_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Disables the streaming initiated by enable_streaming()."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_disable_streaming(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Writes the image into a file defined by its extension."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param view : View of the image (SL_VIEW)."]
    #[doc = "\\param file_name : file path including the name and extension."]
    #[doc = "\\return SUCCESS if the image was successfuly saved."]
    pub fn sl_save_current_image(
        camera_id: ::std::os::raw::c_int,
        view: SL_VIEW,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Writes the depth map into a file defined by its extension."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param side : side of the image (0 = left, 1 = right)."]
    #[doc = "\\param file_name : file path including the name and extension."]
    #[doc = "\\return SUCCESS if the depth was successfuly saved."]
    pub fn sl_save_current_depth(
        camera_id: ::std::os::raw::c_int,
        side: SL_SIDE,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Writes the point cloud into a file defined by its extension."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param side : side of the pc (0 = left, 1 = right)."]
    #[doc = "\\param file_name : file path including the name and extension."]
    #[doc = "\\return SUCCESS if the point cloud was successfuly saved."]
    pub fn sl_save_current_point_cloud(
        camera_id: ::std::os::raw::c_int,
        side: SL_SIDE,
        file_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Initializes and starts the Deep Learning detection module."]
    #[doc = "\\n The object detection module currently supports two types of detection :"]
    #[doc = "- Multiple class of objects with the \\ref DETECTION_MODEL::MULTI_CLASS_BOX, \\ref DETECTION_MODEL::MULTI_CLASS_BOX_MEDIUM or \\ref DETECTION_MODEL::MULTI_CLASS_BOX_ACCURATE."]
    #[doc = "The full list of detectable objects is available through \\ref OBJECT_CLASS and \\ref OBJECT_SUBCLASS."]
    #[doc = "- Human skeleton detection with the \\ref DETECTION_MODEL::HUMAN_BODY_FAST,\\ref DETECTION_MODEL::HUMAN_BODY_MEDIUM or \\ref DETECTION_MODEL::HUMAN_BODY_ACCURATE."]
    #[doc = "This model only detects humans but also provides a full skeleton map for each person."]
    #[doc = ""]
    #[doc = "Detected objects can be retrieved using the \\ref retrieve_objects() function."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param object_detection_parameters : structure containing all specific parameters for object detection (see \\ref SL_ObjectDetectionParameters)."]
    #[doc = "\\return"]
    #[doc = "- \\ref ERROR_CODE::SUCCESS : if everything went fine.\\n"]
    #[doc = "- \\ref ERROR_CODE::CORRUPTED_SDK_INSTALLATION : if the AI model is missing or corrupted. In this case, the SDK needs to be reinstalled.\\n"]
    #[doc = "- \\ref ERROR_CODE::MODULE_NOT_COMPATIBLE_WITH_CAMERA : if the camera used does not have a IMU (ZED Camera). the IMU gives the gravity vector that helps in the 3D box localization.\\n"]
    #[doc = "- \\ref ERROR_CODE::MOTION_SENSORS_REQUIRED : if the camera model is correct (ZED2/ZED2i) but the IMU is missing. It probably happens because InitParameters::disable_sensors was set to true.\\n"]
    #[doc = "- \\ref ERROR_CODE::INVALID_FUNCTION_CALL : if one of the ObjectDetection parameter is not compatible with other modules parameters (For example, depth mode has been set to NONE).\\n"]
    #[doc = "- \\ref ERROR_CODE::FAILURE : otherwise.\\n"]
    pub fn sl_enable_objects_detection(
        camera_id: ::std::os::raw::c_int,
        object_detection_parameters: *mut SL_ObjectDetectionParameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Pauses or resumes the object detection processes."]
    #[doc = ""]
    #[doc = "If the object detection has been enabled with  \\ref ObjectDetectionParameters::image_sync set to false (running asynchronously), this function will pause processing."]
    #[doc = ""]
    #[doc = "While in pause, calling this function with <i>status = false</i> will resume the object detection."]
    #[doc = "The \\ref retrieveObjects function will keep on returning the last objects detected while in pause."]
    #[doc = ""]
    #[doc = "\\param status : If true, object detection is paused. If false, object detection is resumed."]
    pub fn sl_pause_objects_detection(camera_id: ::std::os::raw::c_int, status: bool);
}
extern "C" {
    #[doc = "\\brief Disables the Object Detection process."]
    #[doc = ""]
    #[doc = "The object detection module immediately stops and frees its memory allocations."]
    #[doc = "\\param camera_id : id of the camera instance."]
    pub fn sl_disable_objects_detection(camera_id: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = "\\brief Generate a UUID like unique ID to help identify and track AI detections"]
    #[doc = "\\param uuid : Unique ID generated."]
    #[doc = "\\return : Size of the unique ID generated."]
    pub fn sl_generate_unique_id(uuid: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Feed the 3D Object tracking function with your own 2D bounding boxes from your own detection algorithm."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param objects_in : 2D detections from custom detection algorithm."]
    #[doc = "\\param nb_objects : number of custom objects (size of the object_in array)."]
    #[doc = "\\note The detection should be done on the current grabbed left image as the internal process will use all current available data to extract 3D informations and perform object tracking."]
    #[doc = "\\return \\ref SUCCESS if everything went fine, \\ref ERROR_CODE::FAILURE otherwise"]
    pub fn sl_ingest_custom_box_objects(
        camera_id: ::std::os::raw::c_int,
        nb_objects: ::std::os::raw::c_int,
        objects_in: *mut SL_CustomBoxObjectData,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Retrieve objects detected by the object detection module."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param objects : The detected objects will be saved into this object. If the object already contains data from a previous detection, it will be updated, keeping a unique ID for the same person."]
    #[doc = "\\param object_detection_runtime_parameters : Object detection runtime settings, can be changed at each detection. In async mode, the parameters update is applied on the next iteration."]
    #[doc = "\\return \\ref SUCCESS if everything went fine, \\ref ERROR_CODE::FAILURE otherwise"]
    pub fn sl_retrieve_objects(
        camera_id: ::std::os::raw::c_int,
        object_detection_runtime_parameters: *mut SL_ObjectDetectionRuntimeParameters,
        objects: *mut SL_Objects,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Updates the internal batch of detected objects."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param [Out] : number of batches."]
    #[doc = "\\return \\ref SUCCESS if everything went fine, \\ref ERROR_CODE::FAILURE otherwise"]
    pub fn sl_update_objects_batch(
        camera_id: ::std::os::raw::c_int,
        nb_batches: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets a batch of detected objects. Need to be called after update_objects_batch()."]
    #[doc = "\\param camera_id : id of the camera instance."]
    #[doc = "\\param index : index of the batch to retrieve ([0, nb_batches])."]
    #[doc = "\\param nb_data : number of detected objects in the batch."]
    #[doc = "\\param id : The trajectory ID."]
    #[doc = "\\param label : Object Category. Identify the object type (SL_OBJECT_CLASS)."]
    #[doc = "\\param sublabel : Object subclass (SL_OBJECT_SUBCLASS)."]
    #[doc = "\\param tracking_state : defines the object tracking state (SL_OBJECT_TRACKING_STATE)."]
    #[doc = "\\param positions : a sample of 3D positions."]
    #[doc = "\\param position_covariances : a sample of the associated position covariances."]
    #[doc = "\\param velocities : a sample of 3D velocity."]
    #[doc = "\\param timestamps : The associated position timestamp."]
    #[doc = "\\param bounding_boxes_2d : 2D bounding box of the person represented as four 2D points starting at the top left corner and rotation clockwise."]
    #[doc = "Expressed in pixels on the original image resolution, [0,0] is the top left corner."]
    #[doc = "A ------ B"]
    #[doc = "| Object |"]
    #[doc = "D ------ C"]
    #[doc = "\\param bounding_box : a sample of 3d bounding boxes."]
    #[doc = "\\param confidences : a sample of object detection confidence."]
    #[doc = "\\param action_states : a sample of object action state (SL_OBJECT_ACTION_STATE)."]
    #[doc = "\\param keypoints_2d : a sample of 2d position keypoints."]
    #[doc = "Not available with DETECTION_MODE::MULTI_CLASS_BOX."]
    #[doc = "\\param keypoints : a sample of 3d position keypoints."]
    #[doc = "Not available with DETECTION_MODE::MULTI_CLASS_BOX."]
    #[doc = "\\param head_bounding_boxes_2d : bounds the head with four 2D points."]
    #[doc = "Not available with DETECTION_MODE::MULTI_CLASS_BOX."]
    #[doc = "\\param head_bounding_boxes :  bounds the head with eight 3D points."]
    #[doc = "Not available with DETECTION_MODE::MULTI_CLASS_BOX."]
    #[doc = "\\param head_positions : 3D head centroids."]
    #[doc = "\\param keypoint_confidences : Per keypoint detection confidence, can not be lower than the \\ref ObjectDetectionRuntimeParameters::detection_confidence_threshold."]
    #[doc = "Not available with DETECTION_MODEL::MULTI_CLASS_BOX."]
    #[doc = "\\return \\ref SUCCESS if everything went fine, \\ref ERROR_CODE::FAILURE otherwise"]
    pub fn sl_get_objects_batch(
        camera_id: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        objs_batch: *mut SL_ObjectsBatch,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sl_get_objects_batch_csharp(
        camera_id: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        nb_data: *mut ::std::os::raw::c_int,
        id: *mut ::std::os::raw::c_int,
        label: *mut ::std::os::raw::c_int,
        sublabel: *mut ::std::os::raw::c_int,
        tracking_state: *mut ::std::os::raw::c_int,
        positions: *mut SL_Vector3,
        position_covariances: *mut [f32; 6usize],
        velocities: *mut SL_Vector3,
        timestamps: *mut ::std::os::raw::c_ulonglong,
        bounding_boxes_2d: *mut [SL_Vector2; 4usize],
        bounding_boxes: *mut [SL_Vector3; 8usize],
        confidences: *mut f32,
        action_states: *mut ::std::os::raw::c_int,
        keypoints_2d: *mut [SL_Vector2; 18usize],
        keypoints: *mut [SL_Vector3; 18usize],
        head_bounding_boxes_2d: *mut [SL_Vector2; 4usize],
        head_bounding_boxes: *mut [SL_Vector3; 8usize],
        head_positions: *mut SL_Vector3,
        keypoints_confidences: *mut [f32; 18usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Creates a Mat with the given resolution."]
    #[doc = "\\param width : width of the new mat."]
    #[doc = "\\param height : height of the new mat."]
    #[doc = "\\param type : Data type and number of channels the Mat will hold (see \\ref SL_MAT_TYPE)."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return Ptr of the Mat."]
    pub fn sl_mat_create_new(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SL_MAT_TYPE,
        mem: SL_MEM,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Creates an empty Mat with the given resolution."]
    #[doc = "\\return Ptr of the Mat."]
    pub fn sl_mat_create_new_empty() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Tells if the Mat has been initialized."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return True if the Mat has been initialized."]
    pub fn sl_mat_is_init(ptr: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief Frees the memory of the Mat."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return True if the Mat has been initialized."]
    pub fn sl_mat_free(ptr: *mut ::std::os::raw::c_int, mem: SL_MEM);
}
extern "C" {
    #[doc = "\\brief Returns information about the Mat."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param buffer : buffer providing Mat information."]
    pub fn sl_mat_get_infos(ptr: *mut ::std::os::raw::c_int, buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_uchar(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_uchar,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_uchar2(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Uchar2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_uchar3(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Uchar3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn mat_get_value_uchar4(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Uchar4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_float(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut f32,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_float2(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Vector2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_float3(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Vector3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns the value of a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_get_value_float4(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: *mut SL_Vector4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_uchar(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: ::std::os::raw::c_uchar,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn mat_set_value_uchar2(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Uchar2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value [Out] : the value to get."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_uchar3(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Uchar3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_uchar4(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Uchar4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_float(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: f32,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_float2(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Vector2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_float3(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Vector3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Sets a value to a specific point in the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param col : specifies the column."]
    #[doc = "\\param raw : specifices the row."]
    #[doc = "\\param value : the value to be set."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_value_float4(
        ptr: *mut ::std::os::raw::c_int,
        col: ::std::os::raw::c_int,
        raw: ::std::os::raw::c_int,
        value: SL_Vector4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_uchar(
        ptr: *mut ::std::os::raw::c_int,
        value: ::std::os::raw::c_uchar,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_uchar2(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Uchar2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_uchar3(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Uchar3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_uchar4(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Uchar4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_float(
        ptr: *mut ::std::os::raw::c_int,
        value: f32,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_float2(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Vector2,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_float3(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Vector3,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Fills the entire Mat with the given value."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param value : the value with which to fill the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_to_float4(
        ptr: *mut ::std::os::raw::c_int,
        value: SL_Vector4,
        mem: SL_MEM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Copies data from the GPU to the CPU, if possible."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_update_cpu_from_gpu(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Copies data from the CPU to the GPU, if possible."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_update_gpu_from_cpu(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Copies data from this Mat to another Mat (deep copy)."]
    #[doc = "\\param ptr : Ptr to the Source Mat."]
    #[doc = "\\param ptr_dest : Ptr to the Destination Mat."]
    #[doc = "\\param cpy_type : The To and From memory types (see \\ref SL_COPY_TYPE)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_copy_to(
        ptr: *mut ::std::os::raw::c_int,
        ptr_dest: *mut ::std::os::raw::c_int,
        cpy_type: SL_COPY_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Reads an image from a file. Supports .png and .jpeg. Only works if Mat has access to MEM_CPU."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param file_path : File path, including file name and extension."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_read(
        ptr: *mut ::std::os::raw::c_int,
        file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Writes the Mat into a file as an image. Only works if Mat has access to MEM_CPU."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param file_path : File path, including file name and extension."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_write(
        ptr: *mut ::std::os::raw::c_int,
        file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the Width of the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The width of the matrix."]
    pub fn sl_mat_get_width(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the Height of the matrix."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The height of the matrix."]
    pub fn sl_mat_get_height(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the number of channels stored in each pixel."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return Number of values/channels."]
    pub fn sl_mat_get_channels(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the type of memory (CPU and/or GPU)."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The memory type (SL_MEM)."]
    pub fn sl_mat_get_memory_type(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the size in bytes of one pixel."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The size in bytes of one pixel."]
    pub fn sl_mat_get_pixel_bytes(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the memory 'step' in number/length of elements - how many values make up each row of pixels."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The Step length."]
    pub fn sl_mat_get_step(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the memory 'step' in bytes - how many bytes make up each row of pixels."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The Step length in bytes."]
    pub fn sl_mat_get_step_bytes(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets the size of each row in bytes."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The size of each row in bytes."]
    pub fn sl_mat_get_width_bytes(ptr: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Returns whether the Mat is the owner of the memory it's accessing."]
    #[doc = "\\return True if the Mat is the owner of the memory it's accessing."]
    pub fn sl_mat_is_memory_owner(ptr: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = "\\brief Returns the resolution of the image that this Mat holds."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\return The resolution of the mat."]
    pub fn sl_mat_get_resolution(ptr: *mut ::std::os::raw::c_int) -> SL_Resolution;
}
extern "C" {
    #[doc = "\\brief Allocates memory for the Mat."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param width : Width of the image/matrix in pixels."]
    #[doc = "\\param height : Height of the image/matrix in pixels."]
    #[doc = "\\param type : Data type and number of channels the Mat will hold (see \\ref SL_MAT_TYPE)."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory ( \\ref SL_MEM)."]
    pub fn sl_mat_alloc(
        ptr: *mut ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        type_: SL_MAT_TYPE,
        mem: SL_MEM,
    );
}
extern "C" {
    #[doc = "\\brief Copies data from another Mat into this one(deep copy)."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param ptr_srouce : Source Mat from which to copy."]
    #[doc = "\\param copy_type : The To and From memory types (SL_COPY_TYPE)."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory (SL_MEM)."]
    #[doc = "\\return ERROR_CODE::SUCCESS if everything went well, ERROR_CODE::FAILURE otherwise."]
    pub fn sl_mat_set_from(
        ptr: *mut ::std::os::raw::c_int,
        ptr_source: *mut ::std::os::raw::c_int,
        copy_type: SL_COPY_TYPE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Gets a pointer to the Mat."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param mem : Whether Mat should exist on CPU or GPU memory ( \\ref SL_MEM)."]
    #[doc = "\\return A pointer to the Mat."]
    pub fn sl_mat_get_ptr(
        ptr: *mut ::std::os::raw::c_int,
        mem: SL_MEM,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Duplicates a Mat by copying all its data into a new one (deep copy)."]
    #[doc = "\\param ptr : Ptr to the Mat."]
    #[doc = "\\param ptr_srouce : Source Mat from which to copy."]
    pub fn sl_mat_clone(ptr: *mut ::std::os::raw::c_int, ptr_source: *mut ::std::os::raw::c_int);
}
